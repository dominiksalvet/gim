#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2018-2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://gitlab.com/dominiksalvet/gim
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This function represents a gim entry point and it is expected to be executed
#   first of all, yet its calling should be at the end of this script.
# PARAMETERS:
#   $@ - gim parameters
main() {
    check_deps &&
    init_const &&
    init_cfg_paths &&
    init_global_vars &&
    process_args "$@" || return
}

#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_deps() {
    # a list of required software
    readonly SW_REQUIRED='command git make mkdir sed grep rm ls rmdir id true false dirname wc read cp realpath cut'

    # check if any piece of software is missing
    for sw in $SW_REQUIRED; do
        if ! command -v -- "$sw" > /dev/null; then
            echo "$0: missing $sw software" >&2
            return 2
        fi
    done
}

#-------------------------------------------------------------------------------
# DEFINITIONS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes gim constant data.
init_const() {
    # the current version of gim
    readonly VERSION=6.0.0

    # gim actions
    readonly ACTION_INSTALL=install
    readonly ACTION_UNINSTALL=uninstall
    readonly ACTION_STATUS=status
    readonly ACTION_UPDATE=update # can't be directly invoked by a user

    # version comparison statuses
    readonly VSTATUS_NO_SRC_VER=nothing
    readonly VSTATUS_DIFF=old
    readonly VSTATUS_MATCH=latest

    # available installer methods
    readonly IMETHOD_CAM=cam # Configure & Makefile
    readonly IMETHOD_MAKEFILE=makefile # Makefile

    # static error statuses
    readonly ESTATUS_NO_TAR_VER=NO-TAR-VER
    readonly ESTATUS_UNSUP_SRC_VER=UNSUP-SRC-VER

    # installer error statuses
    readonly ESTATUS_NO_INSTALL_METHOD=NO-INSTALL-METHOD
    readonly ESTATUS_NO_UNINSTALL_METHOD=NO-UNINSTALL-METHOD
    readonly ESTATUS_CONFIGURE_FAIL=CONFIGURE-FAIL
    readonly ESTATUS_MAKE_FAIL=MAKE-FAIL
    readonly ESTATUS_MAKE_INSTALL_FAIL=MAKE-INSTALL-FAIL
    readonly ESTATUS_MAKE_UNINSTALL_FAIL=MAKE-UNINSTALL-FAIL

    # constant string data
    readonly HELP_MESSAGE="USAGE:
  $0 ACTION [OPTION...] URL...
  $0 COMMAND

ACTION:
  $ACTION_INSTALL    install/update Git projects
  $ACTION_UNINSTALL  uninstall Git projects
  $ACTION_STATUS     show status of Git projects

OPTION:
  -fail-on-prompt  fail when user input is required
  -force           force to work when technically possible

COMMAND:
  autoclean  remove old cache
  clean      remove all cache
  help       show this help
  about      show information
  version    show version"

    readonly ABOUT_MESSAGE="gim $VERSION
A simple smart installation manager for your Git projects.

Copy"'right 2018-2019 Dominik Salvet
SPDX License Identifier: MIT
https://gitlab.com/dominiksalvet/gim'

    readonly HINT_MESSAGE="Try '$0 help' for getting help."
}

# DESCRIPTION:
#   Initializes absolute directory paths where gim configuration is stored.
#   Those paths are expected to be constant during the gim's development.
init_cfg_paths() {
    # global gim installation's configuration directory (used for the root)
    readonly GLOBAL_CFG_DIR=/etc/gim
    # local gim installation's configuration directory (used for users)
    readonly LOCAL_CFG_DIR="$HOME"/.config/gim
}

# DESCRIPTION:
#   Defines all global variables. If there is a global variable, it must be
#   stated here even if its value is going to be overwritten.
init_global_vars() {
    # used for the '-force' option
    use_force=false
    # represents error statuses, which may arise during gim's execution
    error_statuses=
}

#-------------------------------------------------------------------------------
# ARGUMENTS PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given gim parameters and performs all associated operations.
# PARAMETERS:
#   $@ - gim parameters
process_args() {
    action=
    accept_action_options=true
    
    for arg in "$@"; do # process each argument individually
        if [ "$action" ]; then
            if "$accept_action_options"; then
                case "$arg" in
                    -fail-on-prompt)
                        export GIT_TERMINAL_PROMPT=0
                        ;;
                    -force)
                        use_force=true
                        ;;
                    -*)
                        echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                        return 1
                        ;;
                    *)
                        init_runtime "$GLOBAL_CFG_DIR" "$LOCAL_CFG_DIR" || return
                        accept_action_options=false # expecting first URL
                        ;;
                esac
            fi

            if ! "$accept_action_options"; then
                process_action "$action" "$arg" || return
            fi
        else
            case "$arg" in
                "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
                    action="$arg" # use the given action
                    ;;
                autoclean)
                    init_runtime "$GLOBAL_CFG_DIR" "$LOCAL_CFG_DIR" &&
                    autoclean
                    return
                    ;;
                clean)
                    init_runtime "$GLOBAL_CFG_DIR" "$LOCAL_CFG_DIR" &&
                    rm -r -f "${GIM_CACHE_REPO_DIR:?}"/*
                    return
                    ;;
                help) echo "$HELP_MESSAGE"; return 0 ;;
                about) echo "$ABOUT_MESSAGE"; return 0 ;;
                version) echo "$VERSION"; return 0 ;;
                *)
                    echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                    return 1
                    ;;
            esac
        fi
    done

    if [ ! "$action" ] || "$accept_action_options"; then
        echo "$0: missing required arguments
$HINT_MESSAGE" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# RUNTIME INITIALIZATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prepares a runtime environment for gim. After calling this function, it is
#   possible to work with gim's database and cache.
# PARAMETERS:
#   $1 - global configuration directory path
#   $2 - local configuration directory path
init_runtime() {
    load_cfg "$1" "$2" &&
    verify_cfg && # verify that the configuration is sufficient
    init_runtime_const &&
    init_storage &&
    export_vars || return
}

# DESCRIPTION:
#   Loads gim dynamic configuration data and determines an installation type.
#   That may involve in reading (sourcing) multiple files. If key files don't
#   exist, returns fail.
# PARAMETERS:
#   $1 - global configuration directory path
#   $2 - local configuration directory path
# shellcheck disable=1090
load_cfg() {
    if [ "$(id -u)" -eq 0 ]; then # global configuration will be used
        . "$1"/gimrc-global &&
        if [ -r "$1"/gimrc ]; then
            . "$1"/gimrc # custom user-defined RC file
        elif [ ! -e "$1"/gimrc ]; then # if not existing
            cp "$1"/gimrc-global "$1"/gimrc # create gimrc from gimrc-global
        fi
    else # local configuration will be used
        if [ -r "$1"/gimrc-local ] && [ ! -r "$2"/gimrc-local ]; then
            gimrc_local_path="$1"/gimrc-local # local configuration provided by global installation
        else
            # prefer sourcing local gimrc (in case of an error, it would be more helpful)
            gimrc_local_path="$2"/gimrc-local
        fi &&
        . "$gimrc_local_path" &&
        if [ -r "$2"/gimrc ]; then
            . "$2"/gimrc # custom user-defined RC file
        elif [ ! -e "$2"/gimrc ]; then # if not existing
            mkdir -p "$2"/ &&
            cp "$gimrc_local_path" "$2"/gimrc # create gimrc from gimrc-local
        fi
    fi || return
}

# DESCRIPTION:
#   Verifies that appropriate constants were successfully loaded.
verify_cfg() { (
    # it must be listed here to provide a good error report
    : "${GIM_DB_DIR:?}" "${GIM_CACHE_DIR:?}" "${GIM_INSTALLER_PREFIX:?}"

    # gim's paths can't start with '-'
    first_chars="$(echo "$GIM_DB_DIR" | cut -c1)" # get first character of each variable
    first_chars="$first_chars""$(echo "$GIM_CACHE_DIR" | cut -c1)"
    if echo "$first_chars" | grep -q -E -e '-'; then # concatenation then must not include '-'
        echo "$0: configuration paths can't start with '-'" >&2
        return 1
    fi

    # check if gim's path is set to '/', which could be dangerous
    if [ "$(realpath -m "$GIM_DB_DIR")" = / ] || [ "$(realpath -m "$GIM_CACHE_DIR")" = / ]; then
        echo "$0: configuration paths can't be set to '/'" >&2
        return 1
    fi
) }

# DESCRIPTION:
#   Initializes runtime constants created from loaded configuration variables.
init_runtime_const() {
    readonly GIM_STATUS_PATH="$GIM_DB_DIR"/status # database of installed projects
    readonly GIM_CACHE_REPO_DIR="$GIM_CACHE_DIR"/repo # cache for Git repositories
}

# DESCRIPTION:
#   Initializes gim's storage structure including the check of gim's database
#   based on prepared global variables.
init_storage() {
    # check if gim status file exists
    if [ ! -e "$GIM_STATUS_PATH" ]; then
        mkdir -p "$(dirname "$GIM_STATUS_PATH")" &&
        echo > "$GIM_STATUS_PATH"
    # check if the status file has at least one newline character
    elif [ "$(wc -l < "$GIM_STATUS_PATH")" -eq 0 ]; then
        # append a newline character
        echo >> "$GIM_STATUS_PATH"
    fi &&

    # create directories for gim's cache
    mkdir -p "$GIM_CACHE_REPO_DIR"/ || return
}

# DESCRIPTION:
#   Exports variables for all called makefile targets and scripts by gim.
export_vars() {
    export INSTALLER=gim
}

#-------------------------------------------------------------------------------
# AUTOCLEAN
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs an automatic cleaning of gim's cache. It removes only those files
#   and directories not belonging to a Git project installed on the system.
autoclean() { (
    # change directory to gim's cache
    cd "${GIM_CACHE_REPO_DIR:?}"/ &&

    # go through all cached Git repositories
    for repo_short_url in */*/*; do
        if [ -d "${repo_short_url:?}"/ ]; then
            # if the repository is not in the database, it can be removed
            if ! has_exact_install_record "$repo_short_url"; then
                # remove the project's cached Git repository
                rm -r -f -- "${repo_short_url:?}"/
            fi
        fi
    done &&

    # remove maintainer directories if they are empty
    rm_empty_dirs ./*/* &&

    # remove hostname directories if they are empty
    rm_empty_dirs ./*
) }

# DESCRIPTION:
#   Decides whether a project from a given repository URL has an exact record in
#   gim status list with the given URL.
# PARAMETERS:
#   $1 - short repository URL
has_exact_install_record() {
    get_exact_install_record "$1" > /dev/null
}

# DESCRIPTION:
#   Returns a record corresponding to project from a given URL repository.
#   Otherwise, it returns an empty string and ends with fail. It also fails if
#   the project is installed under a different URL.
# PARAMETERS:
#   $1 - short repository URL
get_exact_install_record() {
    grep -m 1 -E -e '^'"$1"' .+$' "$GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes given directories if they are empty.
# PARAMETERS:
#   $@ - directories paths
rm_empty_dirs() {
    for dir in "$@"; do
        if [ -d "${dir:?}"/ ]; then
            rmdir --ignore-fail-on-non-empty -- "${dir:?}"/
        fi
    done
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself.
# PARAMETERS:
#   $1 - action
#   $2 - repository URL
process_action() {
    # prepare Git URLs and check root permissions
    check_url "$2" &&
    repo_short_url="$(url_to_short_url "$2")" &&

    # prepare Git repository
    touch_repo "$repo_short_url" &&

    # clear error statuses
    error_statuses= &&

    # execute the action itself
    execute_action "$1" "$repo_short_url" || return
}

# DESCRIPTION:
#   Checks whether given URL is supported.
# PARAMETERS:
#   $1 - repository URL
check_url() {
    url_regex='^(|https://)[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}(|.git)$'
    # check the format of given repository URL
    if ! echo "$1" | grep -q -E -e "$url_regex"; then
        echo "$0: unsupported URL delivered" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Transforms a given repository URL into its short variant.
# PARAMETERS:
#   $1 - repository URL
url_to_short_url() {
    echo "$1" | sed -E -e 's|^https://||; s/\.git$//'
}

#-------------------------------------------------------------------------------
# REPOSITORY OBTAINING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned. Otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - short repository URL
touch_repo() { (
    mkdir -p "$GIM_CACHE_REPO_DIR"/"$1"/ &&
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ &&

    if [ ! "$(ls -A)" ]; then # if the cache directory for the target project is empty
        # clone the Git repository master branch to this directory, it can ask a user for a password
        git clone -q --branch master --single-branch "$(short_url_to_long_url "$1")" . &&
        # disable push remote URL
        git remote set-url --push origin ''
    else
        # remove all untracked files and directories (respect .gitignore for performance gains)
        git clean -q -d -f &&
        # discard all changes done to the repository
        git reset -q --hard &&

        # checkout the master branch
        git checkout -q master &&
        # fetch changes from master and merge them into local master branch
        git pull -q
    fi || return
) }

# DESCRIPTION:
#   Transforms a short repository URL into its long equivalent.
# PARAMETERS:
#   $1 - short repository URL
short_url_to_long_url() {
    echo https://"$1".git
}

#-------------------------------------------------------------------------------
# EXECUTE SELECTED ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Executes a given action with an associated local Git repository prepared.
#   Also prints the status after executing the action.
# PARAMETERS:
#   $1 - action
#   $2 - short repository URL
execute_action() {
    # getting project information
    install_record="$(get_any_install_record "$2")"
    local_version="$(echo "$install_record" | sed -E -e 's/^[^ ]*(| )//')"
    repo_version="$(get_repo_version "$2")"

    # getting project status
    version_status="$(get_version_status "$local_version" "$repo_version")"
    report_status="$version_status"
    register_static_error_statuses "$2" "$local_version" "$repo_version"
    
    if [ ! "$error_statuses" ]; then
        case "$1" in
            "$ACTION_INSTALL")
                case "$version_status" in
                    "$VSTATUS_NO_SRC_VER")
                        report_status="$1"
                        install "$2" "$repo_version"
                        ;;
                    "$VSTATUS_DIFF")
                        report_status="$ACTION_UPDATE" # update, not an installation
                        update "$2" "$local_version" "$install_record" "$repo_version"
                        ;;
                esac
                ;;
            "$ACTION_UNINSTALL")
                case "$version_status" in
                    "$VSTATUS_MATCH" | "$VSTATUS_DIFF")
                        report_status="$1"
                        uninstall "$2" "$local_version" "$install_record"
                        ;;
                esac
                ;;
        esac
    fi

    if [ ! "$error_statuses" ] || [ "$1" = "$ACTION_STATUS" ]; then
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version"
    else
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PROJECT INFORMATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns first record, which represents an installation of the project from
#   the given URL. It also matches a different URLs. If nothing found, it
#   returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
get_any_install_record() {
    mirror_urls_path="$GIM_CACHE_REPO_DIR"/"$1"/gim/mirror-urls

    if [ -r "$mirror_urls_path" ]; then
        while read -r repo_mirror_url; do
            repo_mirror_url="$(url_to_short_url "$repo_mirror_url")"
            if install_record="$(get_exact_install_record "$repo_mirror_url")"; then
                echo "$install_record"
                break
            fi
        done < "$mirror_urls_path"
    elif install_record="$(get_exact_install_record "$1")"; then
        echo "$install_record"
    fi
}

# DESCRIPTION:
#   Returns the repository project version from the given URL. If no version or
#   repository found, empty string is returned.
# PARAMETERS:
#   $1 - short repository URL
get_repo_version() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ &&
    git describe --abbrev=0 2>/dev/null
    return 0 # always succeed
) }

#-------------------------------------------------------------------------------
# PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns a status for two given versions.
# PARAMETERS:
#   $1 - source project version
#   $2 - target project version
get_version_status() {
    if [ ! "$1" ]; then
        echo "$VSTATUS_NO_SRC_VER"
    elif [ "$1" = "$2" ]; then
        echo "$VSTATUS_MATCH"
    else
        echo "$VSTATUS_DIFF"
    fi
}

# DESCRIPTION:
#   Returns static error statuses of the given Git project and versions
#   considering the '-force' flag if delivered without running any external
#   code. If there is at least one error status, a trailing space will be
#   appended. Otherwise, returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - target project version
register_static_error_statuses() {
    if [ ! "$3" ]; then
        add_error_status "$ESTATUS_NO_TAR_VER"
    fi
    
    if ! "$use_force" && ! is_supported_version "$1" "$2"; then
        add_error_status "$ESTATUS_UNSUP_SRC_VER"
    fi
}

# DESCRIPTION:
#   Adds a given error status to the global variable representing current gim's
#   error statuses.
# PARAMETERS:
#   $1 - error status
add_error_status() {
    error_statuses="$error_statuses""$1 "
}

# DESCRIPTION:
#   Decides whether a given version is supported within the project of given
#   repository URL.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - version
is_supported_version() {
    unsupported_versions_path="$GIM_CACHE_REPO_DIR"/"$1"/gim/unsupported-versions

    if [ -r "$unsupported_versions_path" ]; then
        while read -r unsupported_version; do
            if [ "$2" = "$unsupported_version" ]; then
                return 1
            fi
        done < "$unsupported_versions_path"
    fi
}

#-------------------------------------------------------------------------------
# CHOOSE AN INSTALLER METHOD
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
install() {
    # choose used installation method
    { installer_method="$(get_installer_method "$1" "$2")" || {
        add_error_status "$ESTATUS_NO_INSTALL_METHOD"; false
    } } &&

    # perform an installation
    case "$installer_method" in
        "$IMETHOD_CAM") cam_install "$1" "$2" ;;
        "$IMETHOD_MAKEFILE") makefile_install "$1" "$2" ;;
    esac &&

    # access gim's database
    insert_install_record "$1 $2"
}

# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
uninstall() {
    # choose used uninstallation method
    { installer_method="$(get_installer_method "$1" "$2")" || {
        add_error_status "$ESTATUS_NO_UNINSTALL_METHOD"; false
    } } &&

    # perform an uninstallation
    case "$installer_method" in
        "$IMETHOD_CAM") cam_uninstall "$1" "$2" ;;
        "$IMETHOD_MAKEFILE") makefile_uninstall "$1" "$2" ;;
    esac &&

    # access gim's database
    erase_install_record "$3"
}

# DESCRIPTION:
#   Update a given project from a given version to another. Also, erases a given
#   installation record from gim's database and inserts a new one.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
#   $4 - target project version
update() {
    uninstall "$1" "$2" "$3" &&
    install "$1" "$4"
}

# PARAMETERS:
#   $1 - short repository URL
#   $2 - project version
get_installer_method() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    if [ -x configure ]; then
        echo "$IMETHOD_CAM"
    elif [ -e Makefile ] || [ -e makefile ]; then
        echo "$IMETHOD_MAKEFILE"
    else
        return 1 # no installer method found, fail
    fi
) }

#-------------------------------------------------------------------------------
# CONFIGURE & MAKEFILE INSTALLER
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
cam_install() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # installation process
    { ./configure --prefix="$GIM_INSTALLER_PREFIX"/ || {
        add_error_status "$ESTATUS_CONFIGURE_FAIL"; false
    } } &&
    { make || { add_error_status "$ESTATUS_MAKE_FAIL"; false; } } &&
    { make install || { add_error_status "$ESTATUS_MAKE_INSTALL_FAIL"; false; } }
) }

# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
cam_uninstall() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # uninstallation process
    { ./configure --prefix="$GIM_INSTALLER_PREFIX"/ || {
        add_error_status "$ESTATUS_CONFIGURE_FAIL"; false
    } } &&
    { make uninstall || { add_error_status "$ESTATUS_MAKE_UNINSTALL_FAIL"; false; } }
) }

#-------------------------------------------------------------------------------
# MAKEFILE INSTALLER
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
makefile_install() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # installation process
    { PREFIX="$GIM_INSTALLER_PREFIX"/ make || {
        add_error_status "$ESTATUS_MAKE_FAIL"; false
    } } &&
    { PREFIX="$GIM_INSTALLER_PREFIX"/ make install || {
        add_error_status "$ESTATUS_MAKE_INSTALL_FAIL"; false
    } }
) }

# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
makefile_uninstall() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # uninstallation process
    { PREFIX="$GIM_INSTALLER_PREFIX"/ make uninstall || {
        add_error_status "$ESTATUS_MAKE_UNINSTALL_FAIL"; false
    } }
) }

#-------------------------------------------------------------------------------
# ACCESS INSTALALTION DATABASE
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Insert a given installation record before the first line of the gim status
#   list, performing no checks.
# PARAMETERS:
#   $1 - installation record
insert_install_record() {
    sed -i -E -e '1i '"$1" "$GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes a given installation record from the gim status list, performing no
#   checks.
# PARAMETERS:
#   $1 - installation record
erase_install_record() {
    sed -i -E -e '\|'"$1"'|d' "$GIM_STATUS_PATH"
}

#-------------------------------------------------------------------------------
# PRINT PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints the status of a given Git project and all associated parameters.
# PARAMETERS:
#   $1 - project statuses
#   $2 - report status
#   $3 - short repository URL
#   $4 - source project version
#   $5 - target project version
print_status() {
    common_prefix="$(create_labels "$1" '<' '>')""[$2] $3"
    case "$2" in
        "$ACTION_INSTALL") echo "$common_prefix $5" ;;
        "$ACTION_UPDATE") echo "$common_prefix $5 <- $4" ;;
        "$ACTION_UNINSTALL" | "$VSTATUS_MATCH") echo "$common_prefix $4" ;;
        "$VSTATUS_DIFF") echo "$common_prefix $4 -> $5" ;;
        "$VSTATUS_NO_SRC_VER") echo "$common_prefix${5:+" -> $5"}" ;;
    esac
}

# DESCRIPTION:
#   Create status labels from given string list and pattern. Uses IFS value to
#   separate label texts. If at least one label is created, a trailing space
#   will be appended.
# PARAMETERS:
#   $1 - string list
#   $2 - label leading string
#   $3 - label trailing string
create_labels() {
    labels=
    for label_text in $1; do
        labels="$labels""$2""$label_text""$3 "
    done
    echo "$labels"
}

#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
