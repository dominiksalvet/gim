#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2018-2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://gitlab.com/dominiksalvet/gim
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# CODE STYLE
#-------------------------------------------------------------------------------
# VARIABLES:
#    name  function local variable
#    NAME  function local constant
#   _name  global variable
#   _NAME  global constant
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This function represents a gim entry point and it is expected to be executed
#   first of all, yet its calling should be at the end of this script.
# PARAMETERS:
#   $@ - gim parameters
main() {
    check_deps &&
    load_const &&
    load_cfg &&
    process_args "$@" || return
}

#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_deps() {
    # a list of required software
    SW_REQUIRED='command echo [ git make cd mkdir sed grep rm ls rmdir head id true false dirname'

    # check if any piece of software is missing
    for sw in $SW_REQUIRED; do
        if ! command -v -- "$sw" > /dev/null; then
            echo "$0: missing $sw software" >&2
            return 1
        fi
    done
}

#-------------------------------------------------------------------------------
# DEFINITIONS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Loads gim constant data.
load_const() {
    # the current version of gim
    _VERSION=5.0.0

    # gim actions
    _ACTION_INSTALL=install
    _ACTION_UNINSTALL=uninstall
    _ACTION_STATUS=status
    _ACTION_UPDATE=update # can't be directly invoked by a user

    # version comparison statuses
    _VSTATUS_NO_SRC_VER=nothing
    _VSTATUS_DIFF=old
    _VSTATUS_MATCH=latest

    # error statuses
    _ESTATUS_NO_TAR_VER=NO-TAR-VER
    _ESTATUS_UNSUP_SRC_VER=UNSUP-SRC-VER
    _ESTATUS_MAKE_FAIL=MAKE-FAIL

    # constant string data
    _HELP_MESSAGE="USAGE:
  $0 ACTION [OPTION...] URL...
  $0 COMMAND

ACTION:
  $_ACTION_INSTALL    install/update Git projects
  $_ACTION_UNINSTALL  uninstall Git projects
  $_ACTION_STATUS     show status of Git projects

OPTION:
  -fail-on-prompt  fail when user input is required
  -force           force to work when technically possible

COMMAND:
  autoclean  remove old cache
  clean      remove all cache
  help       show this help
  about      show information
  version    show version"

    _ABOUT_MESSAGE="gim $_VERSION
Install, update or uninstall Git projects easily with a single command.

Copy"'right 2018-2019 Dominik Salvet
SPDX License Identifier: MIT
https://gitlab.com/dominiksalvet/gim'

    _HINT_MESSAGE="Try '$0 help' for getting help."
}

# DESCRIPTION:
#   Loads gim configuration.
load_cfg() {
    # the gim root directory
    _GIM_ROOT_DIR=/etc/gim

    # the file representing a list of locally installed projects
    _GIM_STATUS_PATH="$_GIM_ROOT_DIR"/status

    # downloaded Git repositories cache
    _GIM_CACHE_REPO_DIR="$_GIM_ROOT_DIR"/cache/repo

    # global variables
    _root_init_done=false
    _use_force=false
}

#-------------------------------------------------------------------------------
# ARGUMENTS PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given gim parameters and performs all associated operations.
# PARAMETERS:
#   $@ - gim parameters
process_args() {
    action=
    accept_options=true
    
    for arg in "$@"; do # process each argument individually
        if [ "$action" ]; then
            if "$accept_options"; then
                case "$arg" in
                    -fail-on-prompt)
                        export GIT_TERMINAL_PROMPT=0
                        ;;
                    -force)
                        _use_force=true
                        ;;
                    -*)
                        echo "$0: unrecognized argument '$arg'
$_HINT_MESSAGE" >&2
                        return 1
                        ;;
                    *)
                        accept_options=false # expecting first URL
                        process_action "$action" "$arg" || return
                        ;;
                esac
            else
                process_action "$action" "$arg" || return
            fi
        else
            case "$arg" in
                "$_ACTION_INSTALL" | "$_ACTION_UNINSTALL" | "$_ACTION_STATUS")
                    action="$arg" # use the given action
                    ;;
                autoclean)
                    root_init || return
                    autoclean
                    return 0
                    ;;
                clean)
                    root_init || return
                    rm -r -f "${_GIM_CACHE_REPO_DIR:?}"/*
                    return 0
                    ;;
                help)
                    echo "$_HELP_MESSAGE"
                    return 0
                    ;;
                about)
                    echo "$_ABOUT_MESSAGE"
                    return 0
                    ;;
                version)
                    echo "$_VERSION"
                    return 0
                    ;;
                *)
                    echo "$0: unrecognized argument '$arg'
$_HINT_MESSAGE" >&2
                    return 1
                    ;;
            esac
        fi
    done

    if [ ! "$action" ] || "$accept_options"; then
        echo "$0: missing required arguments
$_HINT_MESSAGE" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Performs essential checks associated with root permissions. This function
#   should be called before executing the first command, which may require root
#   permissions.
root_init() {
    if "$_root_init_done"; then
        return 0
    fi

    # root permissions
    if [ "$(id -u)" -ne 0 ]; then
        echo "$0: root privileges required" >&2
        return 1
    fi

    # initializing a status file
    {
        mkdir -p "$(dirname "$_GIM_STATUS_PATH")" &&
        if [ ! -f "$_GIM_STATUS_PATH" ]; then
            echo > "$_GIM_STATUS_PATH"
        fi
    } 2>/dev/null || {
        echo "$0: unable to initialize a status file" >&2
        return 1
    }

    _root_init_done=true
}

#-------------------------------------------------------------------------------
# AUTOCLEAN
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs automatic clean of gim's cache. It removes cached repositories of
#   projects that are not currently installed and active in the gim status file.
autoclean() { (
    # go to gim cache
    cd "$_GIM_CACHE_REPO_DIR"/ || return 0

    # go through all Git repositories
    for repo_short_url in */*/*; do
        if [ -d "$repo_short_url"/ ]; then
            # if the repository is not in the status list, it can be removed
            if ! has_exact_install_record "$repo_short_url"; then
                # remove the project's cached Git repository
                rm -r -f "${repo_short_url:?}"/
            fi
        fi
    done

    # remove maintainer directories if they are empty
    rm_empty_dirs "$_GIM_CACHE_REPO_DIR"/*/*

    # remove hostname directories if they are empty
    rm_empty_dirs "$_GIM_CACHE_REPO_DIR"/*
) }

# DESCRIPTION:
#   Decides whether a project from a given repository URL has a record in gim
#   status list with the given URL.
# PARAMETERS:
#   $1 - short repository URL
has_exact_install_record() {
    get_exact_install_record "$1" > /dev/null
}

# DESCRIPTION:
#   Returns a record corresponding to project from a given URL repository.
#   Otherwise, it returns an empty string and ends with fail. It also fails if
#   the project is installed under a different URL.
# PARAMETERS:
#   $1 - short repository URL
get_exact_install_record() {
    grep -m 1 -E -e '^'"$1"' .+$' "$_GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes given directories that are empty.
# PARAMETERS:
#   $@ - directories paths
rm_empty_dirs() {
    for dir in "$@"; do
        if [ -d "$dir"/ ]; then
            rmdir --ignore-fail-on-non-empty -- "$dir"/
        fi
    done
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs checks, prepares target Git repository and executes the action
#   itself.
# PARAMETERS:
#   $1 - action
#   $2 - repository URL
process_action() {
    # prepare Git URLs and check root permissions
    check_url "$2" &&
    repo_short_url="$(url_to_short_url "$2")" &&
    root_init &&

    # prepare Git repository
    touch_repo "$repo_short_url" &&

    # execute the action itself
    execute_action "$1" "$repo_short_url" || return
}

# DESCRIPTION:
#   Check whether given URL is supported.
# PARAMETERS:
#   $1 - repository URL
check_url() {
    URL_REGEX='^(|https://)[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}(|.git)$'
    # check the format of given repository URL
    if ! echo "$1" | grep -q -E -e "$URL_REGEX"; then
        echo "$0: unsupported URL delivered" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Transform a given repository URL into its short variant.
# PARAMETERS:
#   $1 - repository URL
url_to_short_url() {
    echo "$1" | sed -E -e 's|^https://||; s/\.git$//'
}

#-------------------------------------------------------------------------------
# REPOSITORY OBTAINING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned, otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - short repository URL
touch_repo() { (
    repo_dir="$_GIM_CACHE_REPO_DIR"/"$1" &&
    mkdir -p "$repo_dir"/ &&
    cd "$repo_dir"/ &&

    if [ ! "$(ls -A)" ]; then # if the cache directory for the target project is empty
        # clone the Git repository master branch to this directory, it can ask user for a password
        git clone -q --branch master --single-branch "$(short_url_to_long_url "$1")" . &&
        # disable push remote URL
        git remote set-url --push origin ''
    else
        # remove all untracked files and directories
        git clean -q -f -d &&
        # discard all changes done to the cached repositories
        git reset -q --hard &&
        # checkout the master branch
        git checkout -q master &&

        # fetch changes to master branch together with all tags, it can ask user for a password
        git fetch -q --tags origin master &&
        # merge all fetched remote master changes with local master branch
        git merge -q FETCH_HEAD
    fi || return
) }

# DESCRIPTION:
#   Transforms short repository URL into long repository URL.
# PARAMETERS:
#   $1 - short repository URL
short_url_to_long_url() {
    echo https://"$1".git
}

#-------------------------------------------------------------------------------
# EXECUTE SELECTED ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Executes given action with an associated local Git repository prepared. Also
#   prints the status after executing the action.
# PARAMETERS:
#   $1 - action
#   $2 - short repository URL
execute_action() {
    # getting project information
    install_record="$(get_any_install_record "$2")"
    local_version="$(echo "$install_record" | sed -E -e 's/^[^ ]*(| )//')"
    repo_version="$(get_repo_version "$2")"

    # getting project status
    version_status="$(get_version_status "$local_version" "$repo_version")"
    error_statuses="$(get_error_statuses "$2" "$local_version" "$repo_version")"
    report_status="$version_status"
    
    if [ ! "$error_statuses" ]; then
        case "$1" in
            "$_ACTION_INSTALL")
                case "$version_status" in
                    "$_VSTATUS_NO_SRC_VER")
                        report_status="$1"
                        install "$2" "$repo_version"
                        ;;
                    "$_VSTATUS_DIFF")
                        report_status="$_ACTION_UPDATE" # update, not an installation
                        update "$2" "$local_version" "$install_record" "$repo_version"
                        ;;
                esac
                ;;
            "$_ACTION_UNINSTALL")
                case "$version_status" in
                    "$_VSTATUS_MATCH" | "$_VSTATUS_DIFF")
                        report_status="$1"
                        uninstall "$2" "$local_version" "$install_record"
                        ;;
                esac
                ;;
        esac
    fi || error_statuses="$error_statuses""$_ESTATUS_MAKE_FAIL "

    if [ ! "$error_statuses" ] || [ "$1" = "$_ACTION_STATUS" ]; then
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version"
    else
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PROJECT INFORMATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns first record, which represents an installation of the project from
#   the given URL. It also matches a different URLs. If nothing found, it
#   returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
get_any_install_record() {
    repo_url_prefix="$(get_repo_url_prefix "$1")"
    repo_url_names="$(get_repo_url_names "$1")"

    for repo_url_name in $repo_url_names; do
        if install_record="$(get_exact_install_record "$repo_url_prefix"/"$repo_url_name")"; then
            echo "$install_record"
            break
        fi
    done
}

# DESCRIPTION:
#   Returns the prefix part of the given URL.
# PARAMETERS:
#   $1 - short repository URL
get_repo_url_prefix() {
    echo "$1" | sed -E -e 's|/[^/]*$||'
}

# DESCRIPTION:
#   Returns all names that can represent the same repository of given URL.
# PARAMETERS:
#   $1 - short repository URL
get_repo_url_names() {
    repo_url_names="$(echo "$1" | sed -E -e 's|^.*/||')"
    
    gim_names_path="$_GIM_CACHE_REPO_DIR"/"$1"/gim/names
    if [ -r "$gim_names_path" ]; then
        repo_url_names="$repo_url_names $(head -n 1 "$gim_names_path")"
    fi

    echo "$repo_url_names"
}

# DESCRIPTION:
#   Returns repository project version from the given URL. If no version or
#   repository found, empty string is returned.
# PARAMETERS:
#   $1 - short repository URL
get_repo_version() {
    git -C "$_GIM_CACHE_REPO_DIR"/"$1"/ describe --abbrev=0 2>/dev/null
    true
}

#-------------------------------------------------------------------------------
# PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns a status for two given versions.
# PARAMETERS:
#   $1 - source project version
#   $2 - target project version
get_version_status() {
    if [ ! "$1" ]; then
        echo "$_VSTATUS_NO_SRC_VER"
    elif [ "$1" = "$2" ]; then
        echo "$_VSTATUS_MATCH"
    else
        echo "$_VSTATUS_DIFF"
    fi
}

# DESCRIPTION:
#   Returns error statuses of the given Git project and versions considering the
#   '-force' flag if delivered. If there is at least one error status, a
#   trailing space will be appended. Otherwise, returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - target project version
get_error_statuses() {
    error_statuses=

    if [ ! "$3" ]; then
        error_statuses="$error_statuses""$_ESTATUS_NO_TAR_VER "
    fi
    
    if ! "$_use_force" && ! is_supported_version "$1" "$2"; then
        error_statuses="$error_statuses""$_ESTATUS_UNSUP_SRC_VER "
    fi

    echo "$error_statuses"
}

# DESCRIPTION:
#   Decides whether a given version is supported within the project of given
#   repository URL.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - version
is_supported_version() {
    gim_unsupported_path="$_GIM_CACHE_REPO_DIR"/"$1"/gim/unsupported
    if [ -r "$gim_unsupported_path" ]; then
        for unsupported_version in $(head -n 1 "$gim_unsupported_path"); do
            if [ "$2" = "$unsupported_version" ]; then
                return 1
            fi
        done
    fi
}

#-------------------------------------------------------------------------------
# INSTALLATION AND UNINSTALLATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Installs a given project to a given version.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
install() {
    repo_make install "$1" "$2" &&
    insert_install_record "$1 $2"
}

# DESCRIPTION:
#   Uninstalls a given project of a given version. Also erases a given
#   installation record from gim status file.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
uninstall() {
    repo_make uninstall "$1" "$2" &&
    erase_install_record "$3"
}

# DESCRIPTION:
#   Update a given project from a given version to another. Also erases a given
#   installation record from gim status file and creates a inserts a new one.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
#   $4 - target project version
update() {
    uninstall "$1" "$2" "$3" &&
    install "$1" "$4"
}

# DESCRIPTION:
#   Execute a make target in a repository directory over a given version of the
#   repository.
# PARAMETERS:
#   $1 - make target
#   $2 - short repository URL
#   $3 - version
repo_make() { (
    cd "$_GIM_CACHE_REPO_DIR"/"$2"/ && # go to the repository
    git checkout -q "$3" && # use the given version as a tag
    if [ "$1" ]; then
        make "$1" # execute a make target
    else
        make # execute the default make target
    fi &&
    git checkout -q master # checkout the master branch
) }

# DESCRIPTION:
#   Insert a given installation record before the first line of the gim status
#   list, performing no checks.
# PARAMETERS:
#   $1 - installation record
insert_install_record() {
    sed -i -E -e '1i '"$1" "$_GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes a given installation record from the gim status list, performing no
#   checks.
# PARAMETERS:
#   $1 - installation record
erase_install_record() {
    sed -i -E -e '\|'"$1"'|d' "$_GIM_STATUS_PATH"
}

#-------------------------------------------------------------------------------
# PRINT PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints status of the given Git project and all associated parameters.
# PARAMETERS:
#   $1 - project statuses
#   $2 - report status
#   $3 - short repository URL
#   $4 - source project version
#   $5 - target project version
print_status() {
    common_prefix="$(create_labels "$1" '<' '>')""[$2] $3"
    case "$2" in
        "$_ACTION_INSTALL") echo "$common_prefix $5" ;;
        "$_ACTION_UPDATE") echo "$common_prefix $5 <- $4" ;;
        "$_ACTION_UNINSTALL" | "$_VSTATUS_MATCH") echo "$common_prefix $4" ;;
        "$_VSTATUS_DIFF") echo "$common_prefix $4 -> $5" ;;
        "$_VSTATUS_NO_SRC_VER")
            if [ "$5" ]; then
                echo "$common_prefix -> $5"
            else
                echo "$common_prefix"
            fi
            ;;
    esac
}

# DESCRIPTION:
#   Create status labels from given string list and pattern. Uses IFS value to
#   separate label texts. If at least one label is created, a trailing space
#   will be appended.
# PARAMETERS:
#   $1 - string list
#   $2 - label leading string
#   $3 - label trailing string
create_labels() {
    labels=
    for label_text in $1; do
        labels="$labels""$2""$label_text""$3 "
    done
    echo "$labels"
}

#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
