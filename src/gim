#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2018 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://gitlab.com/dominiksalvet/gim
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# list of required software
SW_REQUIRED='command echo [ git make cd mkdir sed grep rm ls rmdir head id'

# check if some software is missing
for sw in $SW_REQUIRED; do
    # software is missing if at least one piece of software is missing
    if ! command -v "$sw" > /dev/null; then
        echo "$0: missing $sw software" >&2
        exit 1
    fi
done

#-------------------------------------------------------------------------------
# DEFINITIONS
#-------------------------------------------------------------------------------

# the current version of the program
VERSION=3.4.0

HELP_MESSAGE="USAGE:
  $0 ACTION URL [MAKE_ARG...]
  $0 COMMAND

ACTION:
  install    install/update a Git project
  uninstall  uninstall a Git project
  status     show status of a Git project

COMMAND:
  -autoclean  remove old cache
  -clean      remove all cache
  -help       show this help
  -about      show information
  -version    show version"

ABOUT_MESSAGE="gim $VERSION
Install, update or uninstall Git projects in an easy way with a single command.

Copy"'right 2018 Dominik Salvet
SPDX License Identifier: MIT
https://gitlab.com/dominiksalvet/gim'

HINT_MESSAGE="Try '$0 -help' for getting help."

# cache directory to store downloaded Git repositories
CACHE_REPO_DIR=/etc/gim/cache

#-------------------------------------------------------------------------------
# PROCESSING ARGUMENTS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Check if running as root.
root_check() {
    if [ "$(id -u)" -ne 0 ]; then
        echo "$0: root privileges required" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Returns first found name of a locally installed project based on a given Git
#   repository as a directory path.
# PARAMETETRS:
#   $1 - repository directory
get_local_project_name() {
    if [ -r "$1"/gim/names ]; then
        _repo_project_names="$(head -n 1 "$1"/gim/names)"
    else
        _repo_project_names="$(echo "$1" | sed -E -e 's|/*$||; s|^.*/||')"
    fi

    for _repo_project_name in $_repo_project_names; do
        if [ -x "$(command -v "$_repo_project_name")" ]; then
            echo "$_repo_project_name"
            break
        fi
    done
}

# DESCRIPTION:
#   Perform autoclean of gim's cache.
autoclean() {
    # go through all cached projects Git repositories
    for _repo_dir in "$CACHE_REPO_DIR"/*/*/*; do
        # expecting a Git repository, so check if it is a directory
        if [ -d "$_repo_dir" ]; then
            # check if the project not installed
            if [ -z "$(get_local_project_name "$_repo_dir")" ]; then
                # remove the project's cached Git repository
                rm -r -f "${_repo_dir:?}"/
            fi
        fi
    done
    # remove maintainer directories if they are empty
    for _maintainer_dir in "$CACHE_REPO_DIR"/*/*; do
        rmdir --ignore-fail-on-non-empty "$_maintainer_dir"/
    done
    # remove hostname directories if they are empty
    for _hostname_dir in "$CACHE_REPO_DIR"/*; do
        rmdir --ignore-fail-on-non-empty "$_hostname_dir"/
    done
}

action=
repo_url=
make_args=
# process each argument individually
for arg in "$@"; do
    if [ ! -z "$action" ]; then # if the action has been selected
        if [ -z "$repo_url" ]; then # if the project repository URL is not set
            # set up URL variable for later processing
            repo_url="$arg"
        # accept only make arguments
        elif [ -z "$make_args" ]; then
            make_args="$arg"
        else
            make_args="$make_args $arg"
        fi
    else
        case "$arg" in
            install)
                action=install
                ;;
            uninstall)
                action=uninstall
                ;;
            status)
                action=status
                ;;
            -autoclean)
                # check if running as root
                root_check || exit
                autoclean
                exit 0
                ;;
            -clean)
                # check if running as root
                root_check || exit
                rm -r -f "${CACHE_REPO_DIR:?}"/*
                exit 0
                ;;
            -help)
                echo "$HELP_MESSAGE"
                exit 0
                ;;
            -about)
                echo "$ABOUT_MESSAGE"
                exit 0
                ;;
            -version)
                echo "$VERSION"
                exit 0
                ;;
            *)
                echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                exit 1
                ;;
        esac
    fi
done

# check if arguments provided
if [ -z "$action" ] || [ -z "$repo_url" ]; then
    echo "$0: missing required arguments
$HINT_MESSAGE" >&2
    exit 1
fi

URL_REGEX='^(|https://)[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}(|.git)$'
# check the format of given repository URL
if ! echo "$repo_url" | grep -q -E -e "$URL_REGEX"; then
    echo "$0: unsupported URL delivered" >&2
    exit 1
fi

# create two individual instances of given URL
repo_long_url="$repo_url"
repo_short_url="$repo_url"

# if the repository URL starts with 'https://'
if echo "$repo_url" | grep -q -E -e '^https://'; then
    repo_short_url="$(echo "$repo_short_url" | sed -E -e 's|^https://||')"
else
    repo_long_url=https://"$repo_long_url"
fi

# if the repository URL ends with '.git'
if echo "$repo_url" | grep -q -E -e '\.git$'; then
    repo_short_url="$(echo "$repo_short_url" | sed -E -e 's/\.git$//')"
else
    repo_long_url="$repo_long_url".git
fi

#-------------------------------------------------------------------------------
# OBTAINING THE REPOSITORY
#-------------------------------------------------------------------------------

# check if running as root
root_check || exit

# repository directory in cache
repo_dir="$CACHE_REPO_DIR/$repo_short_url"

# create a cache directory for the project
mkdir -p "$repo_dir"/ &&
cd "$repo_dir"/ &&

if [ -z "$(ls -A)" ]; then # if the cache directory for the target project is empty
    # clone the Git repository master branch to the this directory
    git clone -q --progress --branch master --single-branch "$repo_long_url" . &&
    # disable push remote URL
    git remote set-url --push origin ''
else
    # remove all untracked files and directories
    git clean -q -f -d &&
    # discard all changes done to the cached repositories
    git reset -q --hard &&

    # apply given fetch remote URL
    git remote set-url origin "$repo_long_url" &&
    # fetch changes to master branch together with all repository tags
    git fetch -q --progress --tags origin master &&
    # merge all fetched remote master changes with local master branch
    git merge -q FETCH_HEAD
fi || exit

STRING_NOTHING=nothing
STRING_LATEST=latest
STRING_INCOMPATIBLE=incompatible
STRING_OLD=old
STRING_FAIL_INSTALL=fail-install
STRING_INSTALL=install
STRING_FAIL_UPDATE=fail-update
STRING_UPDATE=update
STRING_FAIL_UNINSTALL=fail-uninstall
STRING_UNINSTALL=uninstall

# get version of the most recent annotated tag of the obtained Git project if there is any
repo_project_version="$(git describe --abbrev=0)" 2>/dev/null || {
    echo "[$STRING_INCOMPATIBLE] $repo_short_url" >&2
    exit 1
}

#-------------------------------------------------------------------------------
# EXECUTE SELECTED ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns the current version of a given project name.
# PARAMETERS:
#   $1 - local project name
get_local_project_version() {
    # get the current version of the project
    if ! _version="$("$1" --version)" 2>/dev/null; then
        _version="$("$1" -version)" 2>/dev/null
    fi || _version=
    echo "$_version"
}

# DESCRIPTION:
#   Decides whether the given project version of given repository is explicitly
#   listed as unsupported version.
# PARAMETERS:
#   $1 - repository directory
#   $2 - version
is_unsupported() {
    if [ -r "$1"/gim/unsupported ]; then
        for _version in $(head -n 1 "$1"/gim/unsupported); do
            if [ "$_version" = "$2" ]; then
                return 0
            fi
        done
    fi
    return 1
}

STATUS_NOTHING=0
STATUS_LATEST=1
STATUS_INCOMPATIBLE=2
STATUS_UNSUPPORTED=3
STATUS_OLD=4

# DESCRIPTION:
#   Returns status of the given Git project.
# PARAMETERS:
#   $1 - project name
#   $2 - project version
_get_status() {
    if [ ! -z "$1" ]; then # if the project is installed
        if [ -z "$2" ]; then
            echo "$STATUS_INCOMPATIBLE"
        elif is_unsupported "$repo_dir" "$2"; then
            echo "$STATUS_UNSUPPORTED"
        elif [ "$2" = "$repo_project_version" ]; then
            echo "$STATUS_LATEST"
        else
            echo "$STATUS_OLD"
        fi
    else # if the project is not installed
        echo "$STATUS_NOTHING"
    fi
}

# get information about the local project (if installed)
local_project_name="$(get_local_project_name "$repo_dir")"
local_project_version="$(get_local_project_version "$local_project_name")"
local_project_status="$(_get_status "$local_project_name" "$local_project_version")"

# DESCRIPTION:
#   Perform a make target call with given arguments.
# PARAMETERS:
#   $1 - make target
#   $2 - make arguments
call_make() {
    if [ -z "$2" ]; then
        make "$1"
    else
        make "$1" "$2"
    fi
}

# DESCRIPTION:
#   Installs the project of the given version.
# PARAMETERS:
#   $1 - version
_install() {
    git checkout -q "$1" && # use the given version as a tag
    call_make install "$make_args" # install the program
}

# DESCRIPTION:
#   Uninstalls the project of the given version.
# PARAMETERS:
#   $1 - version
_uninstall() {
    git checkout -q "$1" && # use the program version as a tag
    call_make uninstall "$make_args" # uninstall the program
}

# DESCRIPTION:
#   Updates the project from the given version to another.
# PARAMETERS:
#   $1 - source version
#   $2 - target version
_update() {
    _uninstall "$1" &&
    _install "$2"
}

# DESCRIPTION:
#   Prints status of a Git project, reading all required variables.
# PARAMETERS:
#   $1 - project status
_print_status() {
    case "$1" in
        "$STATUS_NOTHING")
            echo "[$STRING_NOTHING] from $repo_short_url"
            ;;
        "$STATUS_LATEST")
            echo "[$STRING_LATEST] $local_project_name $local_project_version from $repo_short_url"
            ;;
        "$STATUS_INCOMPATIBLE")
            echo "[$STRING_INCOMPATIBLE] $local_project_name from $repo_short_url"
            ;;
        "$STATUS_UNSUPPORTED")
            echo "[$STRING_INCOMPATIBLE] $local_project_name $local_project_version from $repo_short_url"
            ;;
        "$STATUS_OLD")
            echo "[$STRING_OLD] $local_project_name $local_project_version -> $repo_project_version from $repo_short_url"
            ;;
    esac
}

case "$action" in
    install)
        case "$local_project_status" in
            "$STATUS_NOTHING")
                _install "$repo_project_version"
                ;;
            "$STATUS_LATEST")
                _print_status "$local_project_status"
                exit 0
                ;;
            "$STATUS_INCOMPATIBLE" | "$STATUS_UNSUPPORTED")
                _print_status "$local_project_status" >&2
                exit 1
                ;;
            "$STATUS_OLD")
                _update "$local_project_version" "$repo_project_version"
                ;;
        esac
        ;;
    uninstall)
        case "$local_project_status" in
            "$STATUS_NOTHING")
                _print_status "$local_project_status"
                exit 0
                ;;
            "$STATUS_LATEST" | "$STATUS_OLD")
                _uninstall "$local_project_version"
                ;;
            "$STATUS_INCOMPATIBLE" | "$STATUS_UNSUPPORTED")
                _print_status "$local_project_status" >&2
                exit 1
                ;;
        esac
        ;;
    status)
        _print_status "$local_project_status"
        exit 0
        ;;
esac || exit

#-------------------------------------------------------------------------------
# VERIFY THE STATUS
#-------------------------------------------------------------------------------

# checkout the master branch for current information about project names from the repository
git checkout -q master

# refresh information about the local project
new_local_project_name="$(get_local_project_name "$repo_dir")"
new_local_project_version="$(get_local_project_version "$new_local_project_name")"
new_local_project_status="$(_get_status "$new_local_project_name" "$new_local_project_version")"

case "$action" in
    install)
        case "$local_project_status" in
            "$STATUS_NOTHING")
                if [ "$new_local_project_status" != "$STATUS_LATEST" ]; then
                    echo "[$STRING_FAIL_INSTALL] $repo_project_version from $repo_short_url" >&2
                    exit 1
                fi
                echo "[$STRING_INSTALL] $new_local_project_name $new_local_project_version from $repo_short_url"
                ;;
            "$STATUS_OLD")
                if [ "$new_local_project_status" != "$STATUS_LATEST" ]; then
                    echo "[$STRING_FAIL_UPDATE] $repo_project_version <- $local_project_name $local_project_version from $repo_short_url" >&2
                    exit 1
                fi
                if [ "$new_local_project_name" = "$local_project_name" ]; then
                    echo "[$STRING_UPDATE] $new_local_project_name $new_local_project_version <- $local_project_version from $repo_short_url"
                else
                    echo "[$STRING_UPDATE] $new_local_project_name $new_local_project_version <- $local_project_name $local_project_version from $repo_short_url"
                fi
                ;;
        esac
        ;;
    uninstall)
        case "$local_project_status" in
            "$STATUS_LATEST" | "$STATUS_OLD")
                if [ "$new_local_project_status" != "$STATUS_NOTHING" ]; then
                    echo "[$STRING_FAIL_UNINSTALL] $local_project_name $local_project_version from $repo_short_url" >&2
                    exit 1
                fi
                echo "[$STRING_UNINSTALL] $local_project_name $local_project_version from $repo_short_url"
                ;;
        esac
        ;;
esac
