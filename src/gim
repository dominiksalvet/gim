#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2018-2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://gitlab.com/dominiksalvet/gim
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This function represents a gim entry point and it is expected to be executed
#   first of all, yet its calling should be at the end of this script.
# PARAMETERS:
#   $@ - gim parameters
main() {
    check_deps &&
    init_const &&
    init_cfg_paths &&
    init_global_vars &&
    process_args "$@" || return
}

#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_deps() {
    # a list of required software
    readonly SW_REQUIRED='command echo [ git make cd mkdir sed grep rm ls rmdir id true false dirname wc read cp'

    # check if any piece of software is missing
    for sw in $SW_REQUIRED; do
        if ! command -v -- "$sw" > /dev/null; then
            echo "$0: missing $sw software" >&2
            return 1
        fi
    done
}

#-------------------------------------------------------------------------------
# DEFINITIONS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes gim constant data.
init_const() {
    # the current version of gim
    readonly VERSION=5.0.0

    # gim actions
    readonly ACTION_INSTALL=install
    readonly ACTION_UNINSTALL=uninstall
    readonly ACTION_STATUS=status
    readonly ACTION_UPDATE=update # can't be directly invoked by a user

    # version comparison statuses
    readonly VSTATUS_NO_SRC_VER=nothing
    readonly VSTATUS_DIFF=old
    readonly VSTATUS_MATCH=latest

    # error statuses
    readonly ESTATUS_NO_TAR_VER=NO-TAR-VER
    readonly ESTATUS_UNSUP_SRC_VER=UNSUP-SRC-VER
    readonly ESTATUS_MAKE_FAIL=MAKE-FAIL

    # constant string data
    readonly HELP_MESSAGE="USAGE:
  $0 ACTION [OPTION...] URL...
  $0 COMMAND

ACTION:
  $ACTION_INSTALL    install/update Git projects
  $ACTION_UNINSTALL  uninstall Git projects
  $ACTION_STATUS     show status of Git projects

OPTION:
  -fail-on-prompt  fail when user input is required
  -force           force to work when technically possible

COMMAND:
  autoclean  remove old cache
  clean      remove all cache
  help       show this help
  about      show information
  version    show version"

    readonly ABOUT_MESSAGE="gim $VERSION
Install, update or uninstall Git projects easily with a single command.

Copy"'right 2018-2019 Dominik Salvet
SPDX License Identifier: MIT
https://gitlab.com/dominiksalvet/gim'

    readonly HINT_MESSAGE="Try '$0 help' for getting help."
}

# DESCRIPTION:
#   Initializes directory paths where gim configuration should be stored.
init_cfg_paths() {
    # global gim installation's configuration directory (used for the root)
    readonly GLOBAL_CFG_DIR=/etc/gim
    # local gim installation's configuration directory (used for users)
    readonly LOCAL_CFG_DIR="$HOME"/.config/gim
}

# DESCRIPTION:
#   Initializes all global variables.
init_global_vars() {
    # used for the '-force' option
    use_force=false

    # installation type, later it will be set and exported
    INSTALL_TYPE=
}

#-------------------------------------------------------------------------------
# ARGUMENTS PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given gim parameters and performs all associated operations.
# PARAMETERS:
#   $@ - gim parameters
process_args() {
    action=
    accept_action_options=true
    
    for arg in "$@"; do # process each argument individually
        if [ "$action" ]; then
            if "$accept_action_options"; then
                case "$arg" in
                    -fail-on-prompt)
                        export GIT_TERMINAL_PROMPT=0
                        ;;
                    -force)
                        use_force=true
                        ;;
                    -*)
                        echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                        return 1
                        ;;
                    *)
                        init_runtime "$GLOBAL_CFG_DIR" "$LOCAL_CFG_DIR" || return
                        accept_action_options=false # expecting first URL
                        ;;
                esac
            fi

            if ! "$accept_action_options"; then
                process_action "$action" "$arg" || return
            fi
        else
            case "$arg" in
                "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
                    action="$arg" # use the given action
                    ;;
                autoclean)
                    init_runtime "$GLOBAL_CFG_DIR" "$LOCAL_CFG_DIR" || return
                    autoclean
                    return 0
                    ;;
                clean)
                    init_runtime "$GLOBAL_CFG_DIR" "$LOCAL_CFG_DIR" || return
                    rm -r -f "${GIM_CACHE_REPO_DIR:?}"/*
                    return 0
                    ;;
                help) echo "$HELP_MESSAGE"; return 0 ;;
                about) echo "$ABOUT_MESSAGE"; return 0 ;;
                version) echo "$VERSION"; return 0 ;;
                *)
                    echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                    return 1
                    ;;
            esac
        fi
    done

    if [ ! "$action" ] || "$accept_action_options"; then
        echo "$0: missing required arguments
$HINT_MESSAGE" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# RUNTIME INITIALIZATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prepares a runtime environment for gim. After calling this function, it is
#   possible to work with gim's database and cache.
# PARAMETERS:
#   $1 - global configuration directory path
#   $2 - local configuration directory path
init_runtime() {
    load_cfg "$1" "$2" &&
    init_runtime_const &&
    init_storage "$GIM_STATUS_PATH" "$GIM_CACHE_REPO_DIR" &&
    export_vars || return
}

# DESCRIPTION:
#   Loads gim dynamic configuration data and determines an installation type.
#   That may involve in reading (sourcing) multiple files. If key files don't
#   exist, returns fail.
# PARAMETERS:
#   $1 - global configuration directory path
#   $2 - local configuration directory path
# shellcheck disable=1090
load_cfg() {
    if [ "$(id -u)" -eq 0 ]; then # global configuration will be used
        . "$1"/gimrc-global &&
        cp -n "$1"/gimrc-global "$1"/gimrc && # copy without overwrite
        . "$1"/gimrc && # custom user-defined RC file
        INSTALL_TYPE=global
    else # local configuration will be used
        if [ -r "$1"/gimrc-local ] && [ ! -r "$2"/gimrc-local ]; then
            gimrc_local_path="$1"/gimrc-local # local configuration provided by global installation
        else
            # prefer sourcing local gimrc (in case of an error, it would be more helpful)
            gimrc_local_path="$2"/gimrc-local
        fi &&
        . "$gimrc_local_path" &&
        mkdir -p "$2" &&
        cp -n "$gimrc_local_path" "$2"/gimrc && # copy without overwrite
        . "$2"/gimrc && # custom user-defined RC file
        INSTALL_TYPE=local
    fi || return
}

# DESCRIPTION:
#   Initializes runtime constants created from loaded configuration variables.
init_runtime_const() {
    # the file representing a database of locally installed projects
    readonly GIM_STATUS_PATH="${GIM_DB_DIR:?}"/status
    # gim cache for downloaded Git repositories and associated files
    readonly GIM_CACHE_REPO_DIR="${GIM_CACHE_DIR:?}"/repo
}

# DESCRIPTION:
#   Initializes gim's storage structure including the check of gim's database.
# PARAMETERS:
#   $1 - gim status file path
#   $2 - gime repository cache directory path
init_storage() {
    # check if gim status file exists
    if [ ! -f "$1" ]; then
        mkdir -p "$(dirname "$1")" &&
        echo > "$1"
    # check if the status file has at least one newline character
    elif [ "$(wc -l < "$1")" -eq 0 ]; then
        # append a newline character
        echo >> "$1"
    fi &&

    # create a directory for gim's cache
    mkdir -p "$2"/ || return
}

# DESCRIPTION:
#   Exports variables for invoked makefile targets and associated scripts.
export_vars() {
    export INSTALLER=gim
    export INSTALL_TYPE
}

#-------------------------------------------------------------------------------
# AUTOCLEAN
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs an automatic cleaning of gim's cache. It removes the cached
#   repositories of projects that are not currently installed and active in the
#   gim status file.
autoclean() { (
    # go to gim cache
    cd "$GIM_CACHE_REPO_DIR"/ || return 0

    # go through all Git repositories
    for repo_short_url in */*/*; do
        if [ -d "$repo_short_url"/ ]; then
            # if the repository is not in the status list, it can be removed
            if ! has_exact_install_record "$repo_short_url"; then
                # remove the project's cached Git repository
                rm -r -f "${repo_short_url:?}"/
            fi
        fi
    done

    # remove maintainer directories if they are empty
    rm_empty_dirs "$GIM_CACHE_REPO_DIR"/*/*

    # remove hostname directories if they are empty
    rm_empty_dirs "$GIM_CACHE_REPO_DIR"/*
) }

# DESCRIPTION:
#   Decides whether a project from a given repository URL has an exact record in
#   gim status list with the given URL.
# PARAMETERS:
#   $1 - short repository URL
has_exact_install_record() {
    get_exact_install_record "$1" > /dev/null
}

# DESCRIPTION:
#   Returns a record corresponding to project from a given URL repository.
#   Otherwise, it returns an empty string and ends with fail. It also fails if
#   the project is installed under a different URL.
# PARAMETERS:
#   $1 - short repository URL
get_exact_install_record() {
    grep -m 1 -E -e '^'"$1"' .+$' "$GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes given directories if they are empty.
# PARAMETERS:
#   $@ - directories paths
rm_empty_dirs() {
    for dir in "$@"; do
        if [ -d "$dir"/ ]; then
            rmdir --ignore-fail-on-non-empty -- "$dir"/
        fi
    done
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself.
# PARAMETERS:
#   $1 - action
#   $2 - repository URL
process_action() {
    # prepare Git URLs and check root permissions
    check_url "$2" &&
    repo_short_url="$(url_to_short_url "$2")" &&

    # prepare Git repository
    touch_repo "$repo_short_url" &&

    # execute the action itself
    execute_action "$1" "$repo_short_url" || return
}

# DESCRIPTION:
#   Checks whether given URL is supported.
# PARAMETERS:
#   $1 - repository URL
check_url() {
    readonly URL_REGEX='^(|https://)[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}(|.git)$'
    # check the format of given repository URL
    if ! echo "$1" | grep -q -E -e "$URL_REGEX"; then
        echo "$0: unsupported URL delivered" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Transforms a given repository URL into its short variant.
# PARAMETERS:
#   $1 - repository URL
url_to_short_url() {
    echo "$1" | sed -E -e 's|^https://||; s/\.git$//'
}

#-------------------------------------------------------------------------------
# REPOSITORY OBTAINING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned. Otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - short repository URL
touch_repo() { (
    repo_dir="$GIM_CACHE_REPO_DIR"/"$1" &&
    mkdir -p "$repo_dir"/ &&
    cd "$repo_dir"/ &&

    if [ ! "$(ls -A)" ]; then # if the cache directory for the target project is empty
        # clone the Git repository master branch to this directory, it can ask a user for a password
        git clone -q --branch master --single-branch "$(short_url_to_long_url "$1")" . &&
        # disable push remote URL
        git remote set-url --push origin ''
    else
        # remove all untracked files and directories
        git clean -q -f -d &&
        # discard all changes done to the cached repositories
        git reset -q --hard &&
        # checkout the master branch
        git checkout -q master &&

        # fetch changes to master branch together with all tags, it can ask a user for a password
        git fetch -q --tags origin master &&
        # merge all fetched remote master changes with local master branch
        git merge -q FETCH_HEAD
    fi || return
) }

# DESCRIPTION:
#   Transforms a short repository URL into its long equivalent.
# PARAMETERS:
#   $1 - short repository URL
short_url_to_long_url() {
    echo https://"$1".git
}

#-------------------------------------------------------------------------------
# EXECUTE SELECTED ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Executes a given action with an associated local Git repository prepared.
#   Also prints the status after executing the action.
# PARAMETERS:
#   $1 - action
#   $2 - short repository URL
execute_action() {
    # getting project information
    install_record="$(get_any_install_record "$2")"
    local_version="$(echo "$install_record" | sed -E -e 's/^[^ ]*(| )//')"
    repo_version="$(get_repo_version "$2")"

    # getting project status
    version_status="$(get_version_status "$local_version" "$repo_version")"
    error_statuses="$(get_error_statuses "$2" "$local_version" "$repo_version")"
    report_status="$version_status"
    
    if [ ! "$error_statuses" ]; then
        case "$1" in
            "$ACTION_INSTALL")
                case "$version_status" in
                    "$VSTATUS_NO_SRC_VER")
                        report_status="$1"
                        install "$2" "$repo_version"
                        ;;
                    "$VSTATUS_DIFF")
                        report_status="$ACTION_UPDATE" # update, not an installation
                        update "$2" "$local_version" "$install_record" "$repo_version"
                        ;;
                esac
                ;;
            "$ACTION_UNINSTALL")
                case "$version_status" in
                    "$VSTATUS_MATCH" | "$VSTATUS_DIFF")
                        report_status="$1"
                        uninstall "$2" "$local_version" "$install_record"
                        ;;
                esac
                ;;
        esac
    fi || error_statuses="$error_statuses""$ESTATUS_MAKE_FAIL "

    if [ ! "$error_statuses" ] || [ "$1" = "$ACTION_STATUS" ]; then
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version"
    else
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PROJECT INFORMATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns first record, which represents an installation of the project from
#   the given URL. It also matches a different URLs. If nothing found, it
#   returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
get_any_install_record() {
    mirror_urls_path="$GIM_CACHE_REPO_DIR"/"$1"/gim/mirror-urls

    if [ -r "$mirror_urls_path" ]; then
        while read -r repo_mirror_url; do
            repo_mirror_url="$(url_to_short_url "$repo_mirror_url")"
            if install_record="$(get_exact_install_record "$repo_mirror_url")"; then
                echo "$install_record"
                break
            fi
        done < "$mirror_urls_path"
    elif install_record="$(get_exact_install_record "$1")"; then
        echo "$install_record"
    fi
}

# DESCRIPTION:
#   Returns the repository project version from the given URL. If no version or
#   repository found, empty string is returned.
# PARAMETERS:
#   $1 - short repository URL
get_repo_version() {
    git -C "$GIM_CACHE_REPO_DIR"/"$1"/ describe --abbrev=0 2>/dev/null
    true
}

#-------------------------------------------------------------------------------
# PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns a status for two given versions.
# PARAMETERS:
#   $1 - source project version
#   $2 - target project version
get_version_status() {
    if [ ! "$1" ]; then
        echo "$VSTATUS_NO_SRC_VER"
    elif [ "$1" = "$2" ]; then
        echo "$VSTATUS_MATCH"
    else
        echo "$VSTATUS_DIFF"
    fi
}

# DESCRIPTION:
#   Returns error statuses of the given Git project and versions considering the
#   '-force' flag if delivered. If there is at least one error status, a
#   trailing space will be appended. Otherwise, returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - target project version
get_error_statuses() {
    error_statuses=

    if [ ! "$3" ]; then
        error_statuses="$error_statuses""$ESTATUS_NO_TAR_VER "
    fi
    
    if ! "$use_force" && ! is_supported_version "$1" "$2"; then
        error_statuses="$error_statuses""$ESTATUS_UNSUP_SRC_VER "
    fi

    echo "$error_statuses"
}

# DESCRIPTION:
#   Decides whether a given version is supported within the project of given
#   repository URL.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - version
is_supported_version() {
    unsupported_versions_path="$GIM_CACHE_REPO_DIR"/"$1"/gim/unsupported-versions

    if [ -r "$unsupported_versions_path" ]; then
        while read -r unsupported_version; do
            if [ "$2" = "$unsupported_version" ]; then
                return 1
            fi
        done < "$unsupported_versions_path"
    fi
}

#-------------------------------------------------------------------------------
# INSTALLATION AND UNINSTALLATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Installs a given project to a given version.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
install() {
    repo_make install "$1" "$2" &&
    insert_install_record "$1 $2"
}

# DESCRIPTION:
#   Uninstalls a given project of a given version. Also erases a given
#   installation record from gim status file.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
uninstall() {
    repo_make uninstall "$1" "$2" &&
    erase_install_record "$3"
}

# DESCRIPTION:
#   Update a given project from a given version to another. Also erases a given
#   installation record from gim status file and creates a inserts a new one.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
#   $4 - target project version
update() {
    uninstall "$1" "$2" "$3" &&
    install "$1" "$4"
}

# DESCRIPTION:
#   Execute a make target in a repository directory over a given version of the
#   repository.
# PARAMETERS:
#   $1 - make target
#   $2 - short repository URL
#   $3 - version
repo_make() { (
    cd "$GIM_CACHE_REPO_DIR"/"$2"/ && # go to the repository
    git checkout -q "$3" && # use the given version as a tag
    if [ "$1" ]; then
        make "$1" # execute a make target
    else
        make # execute the default make target
    fi &&
    git checkout -q master # checkout the master branch
) }

# DESCRIPTION:
#   Insert a given installation record before the first line of the gim status
#   list, performing no checks.
# PARAMETERS:
#   $1 - installation record
insert_install_record() {
    sed -i -E -e '1i '"$1" "$GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes a given installation record from the gim status list, performing no
#   checks.
# PARAMETERS:
#   $1 - installation record
erase_install_record() {
    sed -i -E -e '\|'"$1"'|d' "$GIM_STATUS_PATH"
}

#-------------------------------------------------------------------------------
# PRINT PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints the status of a given Git project and all associated parameters.
# PARAMETERS:
#   $1 - project statuses
#   $2 - report status
#   $3 - short repository URL
#   $4 - source project version
#   $5 - target project version
print_status() {
    common_prefix="$(create_labels "$1" '<' '>')""[$2] $3"
    case "$2" in
        "$ACTION_INSTALL") echo "$common_prefix $5" ;;
        "$ACTION_UPDATE") echo "$common_prefix $5 <- $4" ;;
        "$ACTION_UNINSTALL" | "$VSTATUS_MATCH") echo "$common_prefix $4" ;;
        "$VSTATUS_DIFF") echo "$common_prefix $4 -> $5" ;;
        "$VSTATUS_NO_SRC_VER") echo "$common_prefix${5:+" -> $5"}" ;;
    esac
}

# DESCRIPTION:
#   Create status labels from given string list and pattern. Uses IFS value to
#   separate label texts. If at least one label is created, a trailing space
#   will be appended.
# PARAMETERS:
#   $1 - string list
#   $2 - label leading string
#   $3 - label trailing string
create_labels() {
    labels=
    for label_text in $1; do
        labels="$labels""$2""$label_text""$3 "
    done
    echo "$labels"
}

#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
