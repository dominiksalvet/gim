#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2018 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://gitlab.com/dominiksalvet/gim
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# SOFTWARE DEPENDENCIES
#-------------------------------------------------------------------------------

# list of required software
SW_REQUIRED='command echo [ git make cd mkdir sed grep rm ls rmdir head id'

# check if some software is missing
for sw in $SW_REQUIRED; do
    # software is missing if at least one piece of software is missing
    if ! command -v "$sw" > /dev/null; then
        echo "$0: missing $sw software" >&2
        exit 1
    fi
done

#-------------------------------------------------------------------------------
# CONSTANTS
#-------------------------------------------------------------------------------

# the current version of the program
VERSION=3.4.0

HELP_MESSAGE="USAGE:
  $0 ACTION URL [MAKE_ARG...]
  $0 COMMAND

ACTION:
  install    install a Git project
  update     update a Git project
  uninstall  uninstall a Git project
  status     show status of a Git project

COMMAND:
  -autoclean  remove old cache and exit
  -clean      remove all cache and exit
  -help       show this help and exit
  -about      show information and exit
  -version    show version and exit"

ABOUT_MESSAGE="gim $VERSION
Install, update or uninstall Git projects in an easy way with a single command.

Copy"'right 2018 Dominik Salvet
SPDX License Identifier: MIT
https://gitlab.com/dominiksalvet/gim'

HINT_MESSAGE="Try '$0 -help' for getting help."

# cache directory to store downloaded Git repositories
CACHE_REPO_DIR=/etc/gim/cache

#-------------------------------------------------------------------------------
# PROCESSING ARGUMENTS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Check if running as root.
root_check() {
    if [ "$(id -u)" -ne 0 ]; then
        echo "$0: root privileges required" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Returns first found name of a locally installed project based on a given Git
#   repository as a directory path.
# PARAMETETRS:
#   $1 - repository directory
get_local_project_name() {
    if [ -r "$1"/gim/names ]; then
        _repo_project_names="$(head -n 1 "$1"/gim/names)"
    else
        _repo_project_names="$(echo "$1" | sed -E -e 's|/*$||; s|^.*/||')"
    fi

    for _repo_project_name in $_repo_project_names; do
        if [ -x "$(command -v "$_repo_project_name")" ]; then
            echo "$_repo_project_name"
            break
        fi
    done
}

# DESCRIPTION:
#   Perform autoclean of gim's cache.
autoclean() {
    # go through all cached projects Git repositories
    for _repo_dir in "$CACHE_REPO_DIR"/*/*/*; do
        # expecting a Git repository, so check if it is a directory
        if [ -d "$_repo_dir" ]; then
            # check if the project not installed
            if [ -z "$(get_local_project_name "$_repo_dir")" ]; then
                # remove the project's cached Git repository
                rm -r -f "${_repo_dir:?}/"
            fi
        fi
    done
    # remove maintainer directories if they are empty
    for _maintainer_dir in "$CACHE_REPO_DIR"/*/*; do
        rmdir --ignore-fail-on-non-empty "$_maintainer_dir"/
    done
    # remove hostname directories if they are empty
    for _hostname_dir in "$CACHE_REPO_DIR"/*; do
        rmdir --ignore-fail-on-non-empty "$_hostname_dir"/
    done
}

action=
repo_url=
make_args=
# process each argument individually
for arg in "$@"; do
    if [ ! -z "$action" ]; then # if the action has been selected
        if [ -z "$repo_url" ]; then # if the project repository URL is not set
            # set up URL variable for later processing
            repo_url="$arg"
        # accept only make arguments
        elif [ -z "$make_args" ]; then
            make_args="$arg"
        else
            make_args="$make_args $arg"
        fi
    else
        case "$arg" in
            install)
                action=install
                ;;
            update)
                action=update
                ;;
            uninstall)
                action=uninstall
                ;;
            status)
                action=status
                ;;
            -autoclean)
                # check if running as root
                root_check || exit
                autoclean
                exit 0
                ;;
            -clean)
                # check if running as root
                root_check || exit
                rm -r -f "${CACHE_REPO_DIR:?}"/*
                exit 0
                ;;
            -help)
                echo "$HELP_MESSAGE"
                exit 0
                ;;
            -about)
                echo "$ABOUT_MESSAGE"
                exit 0
                ;;
            -version)
                echo "$VERSION"
                exit 0
                ;;
            *)
                echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                exit 1
                ;;
        esac
    fi
done

# check if arguments provided
if [ -z "$action" ] || [ -z "$repo_url" ]; then
    echo "$0: missing required arguments
$HINT_MESSAGE" >&2
    exit 1
fi

# check the format of given repository URL
if ! echo "$repo_url" | grep -q -E -e '^(|https://)[^/\.][^/]*(/[^\.][^/]*){2}(|\.git)$'; then
    echo "$0: unsupported URL delivered" >&2
    exit 1
fi

# create two individual instances of given URL
repo_long_url="$repo_url"
repo_short_url="$repo_url"

# if the repository URL starts with 'https://'
if echo "$repo_url" | grep -q -E -e '^https://'; then
    repo_short_url="$(echo "$repo_short_url" | sed -E -e 's|^https://||')"
else
    repo_long_url=https://"$repo_long_url"
fi

# if the repository URL ends with '.git'
if echo "$repo_url" | grep -q -E -e '\.git$'; then
    repo_short_url="$(echo "$repo_short_url" | sed -E -e 's/\.git$//')"
else
    repo_long_url="$repo_long_url".git
fi

#-------------------------------------------------------------------------------
# OBTAINING THE REPOSITORY
#-------------------------------------------------------------------------------

# check if running as root
root_check || exit

# extract required information from the given repository URL
repo_hostname="$(echo "$repo_short_url" | sed -E -e 's|/.*$||')"
repo_maintainer="$(echo "$repo_short_url" | sed -E -e 's|/[^/]*$||; s|.*/||')"
repo_name="$(echo "$repo_short_url" | sed -E -e 's|.*/||')"
repo_dir="$CACHE_REPO_DIR/$repo_hostname/$repo_maintainer/$repo_name"

# create a cache directory for the project
mkdir -p "$repo_dir"/ &&
cd "$repo_dir"/ &&

if [ -z "$(ls -A)" ]; then # if the cache directory for the target project is empty
    # clone the Git repository master branch to the this directory
    git clone -q --progress --branch master --single-branch "$repo_long_url" . &&
    # disable push remote URL
    git remote set-url --push origin ''
else
    # remove all untracked files and directories
    git clean -q -f -d &&
    # discard all changes done to the cached repositories
    git reset -q --hard &&

    # apply given fetch remote URL
    git remote set-url origin "$repo_long_url" &&
    # fetch changes to master branch together with all repository tags
    git fetch -q --progress --tags origin master &&
    # merge all fetched remote master changes with local master branch
    git merge -q FETCH_HEAD
fi || exit 1

#-------------------------------------------------------------------------------
# CHECK VERSIONS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns the current version of a given project name.
# PARAMETERS:
#   $1 - local project name
get_local_project_version() {
    # get the current version of the project
    if ! _version="$("$1" --version)" 2>/dev/null; then
        _version="$("$1" -version)" 2>/dev/null
    fi || _version=
    echo "$_version"
}

# get version of the most recent annotated tag of the obtained Git project
repo_project_version="$(git describe --abbrev=0 2>/dev/null)" || {
    echo "[incompatible] $repo_short_url" >&2
    exit 1
}

# get information about the local project (if installed)
local_project_name="$(get_local_project_name "$repo_dir"/)"
local_project_version="$(get_local_project_version "$local_project_name")"

if [ -r "$repo_dir"/gim/unsupported ] && [ ! -z "$local_project_version" ]; then
    if head -n 1 "$repo_dir"/gim/unsupported | grep -q -E -e "$local_project_version"; then
        echo "[incompatible] $local_project_name $local_project_version from $repo_short_url" >&2
        exit 1
    fi
fi

#-------------------------------------------------------------------------------
# EXECUTE SELECTED ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Perform a make target call with given arguments.
# PARAMETERS:
#   $1 - make target
#   $2 - make arguments
call_make() {
    if [ -z "$2" ]; then
        make "$1"
    else
        make "$1" "$2"
    fi
}

case "$action" in
    install)
        if [ ! -z "$local_project_name" ]; then # check if the project already installed
            if [ "$local_project_version" = "$repo_project_version" ]; then # if the versions are the same
                echo "[latest] $local_project_name $local_project_version from $repo_short_url"
                exit 0
            elif [ -z "$local_project_version" ]; then # if not and version flags not supported
                echo "[incompatible] $local_project_name from $repo_short_url" >&2
                exit 1
            else
                echo "[old] $local_project_name $local_project_version -> $repo_project_version from $repo_short_url
POSSIBLE SOLUTIONS:
  * Use the 'update' action instead of the used 'install' action." >&2
                exit 1
            fi
        fi

        git checkout -q "$repo_project_version" && # use the latest repository tag
        call_make install "$make_args" # install the program
        ;;
    update)
        if [ ! -z "$local_project_name" ]; then # check if the project installed
            if [ "$local_project_version" = "$repo_project_version" ]; then # if the versions are the same
                echo "[latest] $local_project_name $local_project_version from $repo_short_url"
                exit 0
            elif [ -z "$local_project_version" ]; then # if not and version flags not supported
                echo "[incompatible] $local_project_name from $repo_short_url" >&2
                exit 1
            fi
        else # the project is not installed
            echo "[nothing] from $repo_short_url
POSSIBLE SOLUTIONS:
  * Use the 'install' action instead of the used 'update' action." >&2
            exit 1
        fi

        git checkout -q "$local_project_version" && # use the program version as a tag
        call_make uninstall "$make_args" && # uninstall the program

        git checkout -q "$repo_project_version" && # use the latest repository tag
        call_make install "$make_args" # install the program again
        ;;
    uninstall)
        if [ -z "$local_project_name" ]; then # if the project is not installed
            echo "[nothing] from $repo_short_url"
            exit 0 # uninstallation exits with a success eventually
        elif [ -z "$local_project_version" ]; then
            echo "[incompatible] $local_project_name from $repo_short_url" >&2
            exit 1
        fi

        git checkout -q "$local_project_version" && # use the program version as a tag
        call_make uninstall "$make_args" # uninstall the program
        ;;
    status)
        if [ -z "$local_project_name" ]; then # if the project is not installed
            echo "[nothing] from $repo_short_url"
        else # project installed
            if [ "$local_project_version" = "$repo_project_version" ]; then # if the versions are the same
                echo "[recent] $local_project_name $local_project_version from $repo_short_url"
            elif [ -z "$local_project_version" ]; then # if not and version flags not supported
                echo "[incompatible] $local_project_name from $repo_short_url"
            else
                echo "[old] $local_project_name $local_project_version -> $repo_project_version from $repo_short_url"
            fi
        fi

        exit 0
        ;;
esac || {
    echo "$0: An error has occurred during the $action action.
POSSIBLE SOLUTIONS:
  * Read the report above as it can provide required information." >&2
    if [ ! -z "$local_project_name" ]; then
        echo "  * Contact a $local_project_name developer." >&2
    else
        echo "  * Contact a $repo_name repository developer." >&2
    fi
    exit 1
}

#-------------------------------------------------------------------------------
# VERIFY THE STATUS
#-------------------------------------------------------------------------------

# checkout the master branch for current information about project names from the repository
git checkout -q master

# refresh information about the local project
new_local_project_name="$(get_local_project_name "$repo_dir/")"
new_local_project_version="$(get_local_project_version "$new_local_project_name")"

case "$action" in
    install)
        if [ -z "$new_local_project_name" ]; then # if the project is not installed (as it should be now)
            echo "$0: A project from $repo_name repository should have been installed, but it is not.
POSSIBLE SOLUTIONS:
  * Contact a $repo_name repository developer about gim compliance.
  * Install the project again." >&2
            exit 1
        else
            echo "[$new_local_project_name $new_local_project_version] has been installed."
        fi
        ;;
    update)
        if [ -z "$new_local_project_name" ]; then # if the project is not installed (as it should be now)
            echo "$0: [$local_project_name $local_project_version] has been uninstalled but it couldn't have been updated ($repo_project_version).
POSSIBLE SOLUTIONS:
  * Contact a $repo_name repository developer about gim compliance.
  * Use the 'install' action instead of the used 'update' action." >&2
            exit 1
        else
            echo "[$local_project_name $local_project_version] has been updated to [$new_local_project_name $new_local_project_version]."
        fi
        ;;
    uninstall)
        if [ ! -z "$new_local_project_name" ]; then # if the project is installed (as it shouldn't be now)
            echo "$0: [$new_local_project_name $new_local_project_version] should have been uninstalled, but it is not.
POSSIBLE SOLUTIONS:
  * Contact a $repo_name repository developer about gim compliance.
  * Uninstall the project again." >&2
            exit 1
        else
            echo "[$local_project_name $local_project_version] has been uninstalled."
        fi
        ;;
esac
