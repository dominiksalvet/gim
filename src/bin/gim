#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2018-2019 Dominik Salvet
# SPDX-License-Identifier: MIT
# https://gitlab.com/dominiksalvet/gim
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# ENTRY POINT
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   This function represents a gim entry point and it is expected to be executed
#   first of all, yet its calling should be at the end of this script.
# PARAMETERS:
#   $@ - gim parameters
main() {
    check_deps && # check software dependencies
    init_constants && # initialize static constants
    init_strings && # initialize string constants
    def_global_vars && # defined global variables used later in this script
    process_args "$@" # process all given arguments
}

# DESCRIPTION:
#   Checks whether all software dependencies are satisfied.
check_deps() {
    # a list of required software
    readonly SW_REQUIRED='command git make mkdir sed grep rm ls rmdir id true false dirname wc read cp realpath cut'

    # check if any piece of software is missing
    for sw in $SW_REQUIRED; do
        if ! command -v -- "$sw" > /dev/null; then
            echo "$0: missing $sw software" >&2
            return 2
        fi
    done
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------
# Variables and constants of this section can be read everywhere in this script.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Initializes static constants.
init_constants() {
    # the current version of gim
    readonly VERSION=6.0.1

    # gim actions
    readonly ACTION_INSTALL=install
    readonly ACTION_UNINSTALL=uninstall
    readonly ACTION_STATUS=status
    readonly ACTION_UPDATE=update # can't be directly invoked by a user

    # version comparison statuses
    readonly VSTATUS_NO_SRC_VER=nothing
    readonly VSTATUS_DIFF=old
    readonly VSTATUS_MATCH=latest

    # available installers
    readonly INSTALLER_CAMI=cami # Configure & Make installer
    readonly INSTALLER_MAKEI=makei # Make installer

    # static target version statuses
    readonly STATUS_NO_TAR_VER=no-tar-ver
    readonly STATUS_NO_TAR_INSTALL=no-tar-install

    # static source version statuses
    readonly STATUS_UNSUP_SRC_VER=unsup-src-ver
    readonly STATUS_NO_SRC_UNINSTALL=no-src-uninstall

    # installer statuses
    readonly STATUS_CONFIGURE_FAIL=configure-fail
    readonly STATUS_MAKE_FAIL=make-fail
    readonly STATUS_MAKE_INSTALL_FAIL=make-install-fail
    readonly STATUS_MAKE_UNINSTALL_FAIL=make-uninstall-fail
}

# DESCRIPTION:
#   Initializes strings usually used to display reports to the user. Constants
#   must be already initialized.
init_strings() {
    readonly HELP_MESSAGE="USAGE:
  $0 ACTION [OPTION...] URL...
  $0 COMMAND

ACTION:
  $ACTION_INSTALL    install/update Git projects
  $ACTION_UNINSTALL  uninstall Git projects
  $ACTION_STATUS     show status of Git projects

OPTION:
  -fail-on-prompt  fail when user input is required
  -force           force to work when technically possible

COMMAND:
  autoclean  remove old cache
  clean      remove all cache
  help       show this help
  about      show information"

    readonly ABOUT_MESSAGE="gim $VERSION
A simple smart installation manager for your Git projects.

Copy"'right 2018-2019 Dominik Salvet
SPDX License Identifier: MIT
https://gitlab.com/dominiksalvet/gim'

    readonly HINT_MESSAGE="Try '$0 help' for getting help."
}

# DESCRIPTION:
#   Defines global variables. If there is a global variable, it must be stated
#   here even though its value is going to be overwritten.
def_global_vars() {
    # used for the '-force' option
    use_force=false

    # statuses that may arise during execution
    error_statuses=
}

#-------------------------------------------------------------------------------
# ARGUMENT PARSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Processes given gim parameters and performs all associated operations.
# PARAMETERS:
#   $@ - gim parameters
process_args() {
    action=
    accept_action_options=true
    
    for arg in "$@"; do # process each argument individually
        if [ "$action" ]; then
            if "$accept_action_options"; then
                case "$arg" in
                    -fail-on-prompt)
                        export GIT_TERMINAL_PROMPT=0
                        ;;
                    -force)
                        use_force=true
                        ;;
                    -*)
                        echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                        return 1
                        ;;
                    *)
                        init_runtime || return
                        accept_action_options=false # expecting first URL
                        ;;
                esac
            fi

            if ! "$accept_action_options"; then
                process_action "$action" "$arg" || return
            fi
        else
            case "$arg" in
                "$ACTION_INSTALL" | "$ACTION_UNINSTALL" | "$ACTION_STATUS")
                    action="$arg" # use the given action
                    ;;
                autoclean)
                    init_runtime &&
                    cache_autoclean
                    return
                    ;;
                clean)
                    init_runtime &&
                    rm -r -f "${GIM_CACHE_REPO_DIR:?}"/*
                    return
                    ;;
                help) echo "$HELP_MESSAGE"; return ;;
                about) echo "$ABOUT_MESSAGE"; return ;;
                *)
                    echo "$0: unrecognized argument '$arg'
$HINT_MESSAGE" >&2
                    return 1
                    ;;
            esac
        fi
    done

    if [ ! "$action" ] || "$accept_action_options"; then
        echo "$0: missing required arguments
$HINT_MESSAGE" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------
# Constants of this section can be read everywhere in this script.
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prepares a runtime environment for gim. After calling this function, gim's
#   essential file structure will be prepared and an appropriate configuration
#   will be applied.
init_runtime() {
    init_paths && # initialize paths related to dynamic initialization
    load_default_rc && # load default configuration
    verify_cfg && # verify that default configuration is valid
    load_custom_rc && # load custom configuration (if it exists)
    verify_cfg && # verify that custom configuration is valid
    init_cfg_constants && # create constants derived from applied configuration
    init_storage && # try to create a file structure, first write access to storage
    check_storage_access && # verify that gim can access required files and directories
    export_vars # export variables for called installers
}

# DESCRIPTION:
#   Initializes constant paths.
init_paths() {
    # gim library path is relative to gim binary path and it must exist
    readonly GIM_LIB_DIR="$(realpath -e -- "$(dirname -- "$0")")"/../lib/gim &&

    # set up the default RC file path according to the used installation type
    if [ "$(id -u)" -eq 0 ]; then # global configuration will be used
        readonly DEFAULT_RC_PATH="$GIM_LIB_DIR"/rc/global
    else # local configuration will be used
        readonly DEFAULT_RC_PATH="$GIM_LIB_DIR"/rc/local
    fi
}

# DESCRIPTION:
#   Loads the default RC file.
load_default_rc() {
    # shellcheck disable=1090
    . "$DEFAULT_RC_PATH"
}

# DESCRIPTION:
#   Verifies that configuration constants are valid.
verify_cfg() {
    # variables that are required to be nonempty must be listed here to provide good error reports
    ( : "${GIM_CFG_DIR:?}" "${GIM_CACHE_DIR:?}" "${GIM_DB_DIR:?}" "${GIM_PREFIX:?}" ) || return

    # paths of gim's directories must not start with '-'
    first_chars="$(echo "$GIM_CFG_DIR" | cut -c1)" # get first character of each variable
    first_chars="$first_chars""$(echo "$GIM_CACHE_DIR" | cut -c1)"
    first_chars="$first_chars""$(echo "$GIM_DB_DIR" | cut -c1)"
    if echo "$first_chars" | grep -q -E -e '-'; then # concatenation then must not include '-'
        echo "$0: configuration paths must not start with '-'" >&2
        return 1
    fi

    # check if gim cache path is set to '/', which could be dangerous
    if [ "$(realpath -m "$GIM_CACHE_DIR")" = / ]; then
        echo "$0: gim cache path must not be set to '/'" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Loads a custom RC file if it exists.
load_custom_rc() {
    if [ -r "$GIM_CFG_DIR"/gimrc ]; then
        # shellcheck disable=1090
        . "$GIM_CFG_DIR"/gimrc # load custom RC file
    fi
}

# DESCRIPTION:
#   Initializes runtime constants derived from read configuration variables.
init_cfg_constants() {
    readonly GIM_CACHE_REPO_DIR="$GIM_CACHE_DIR"/repo # cache for Git repositories
    readonly GIM_STATUS_PATH="$GIM_DB_DIR"/status # database of installed projects
}

# DESCRIPTION:
#   Initializes gim's file structure including the check of gim's database based
#   on prepared global variables. It fails if it cannot create a file or a
#   directory. It does not check file permissions, though.
init_storage() {
    # create custom RC file from the default one if it does not exist
    if [ ! -e "$GIM_CFG_DIR"/gimrc ]; then # if not existing
        mkdir -p "$GIM_CFG_DIR"/ &&
        cp "$DEFAULT_RC_PATH" "$GIM_CFG_DIR"/gimrc # create gimrc from default RC file
    fi &&

    # create cache directory for Git repositories
    mkdir -p "$GIM_CACHE_REPO_DIR"/ &&

    # check if gim status file exists
    if [ ! -e "$GIM_STATUS_PATH" ]; then
        mkdir -p "$(dirname "$GIM_STATUS_PATH")" &&
        echo > "$GIM_STATUS_PATH"
    # check if the status file has at least one newline character
    elif [ "$(wc -l < "$GIM_STATUS_PATH")" -eq 0 ]; then
        # append a newline character
        echo >> "$GIM_STATUS_PATH"
    fi &&

    # create directory for default installation prefix
    mkdir -p -- "$GIM_PREFIX"/
}

# DESCRIPTION:
#   Checks whether gim can access all required files and directories. The gim
#   file structure must already been prepared.
check_storage_access() {
    # check access to files
    if [ ! -r "$GIM_STATUS_PATH" ] || [ ! -w "$GIM_STATUS_PATH" ]; then
        echo "$0: can't access '$GIM_STATUS_PATH' file" >&2
        return 1
    fi

    # check access to directories
    for dir in "$GIM_CACHE_REPO_DIR" "$GIM_PREFIX"; do
        if [ ! -r "$dir"/ ] || [ ! -w "$dir"/ ]; then
            echo "$0: can't access '$dir' directory" >&2
            return 1
        fi
    done
}

# DESCRIPTION:
#   Exports variables for all called installers by gim.
export_vars() {
    export INSTALLER=gim
}

#-------------------------------------------------------------------------------
# AUTOCLEAN
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs an automatic cleaning of gim's cache. It removes only those files
#   and directories not belonging to a Git project installed on the system.
cache_autoclean() { (
    # change directory to gim's cache
    cd "${GIM_CACHE_REPO_DIR:?}"/ &&

    # go through all cached Git repositories
    for repo_short_url in */*/*; do
        if [ -d "${repo_short_url:?}"/ ]; then
            # if the repository is not in the database, it can be removed
            if ! has_exact_install_record "$repo_short_url"; then
                # remove the project's cached Git repository
                rm -r -f -- "${repo_short_url:?}"/
            fi
        fi
    done &&

    # remove maintainer directories if they are empty
    rm_empty_dirs ./*/* &&

    # remove hostname directories if they are empty
    rm_empty_dirs ./*
) }

# DESCRIPTION:
#   Decides whether a project from a given repository URL has an exact record in
#   gim status list with the given URL.
# PARAMETERS:
#   $1 - short repository URL
has_exact_install_record() {
    get_exact_install_record "$1" > /dev/null
}

# DESCRIPTION:
#   Returns a record corresponding to project from a given URL repository.
#   Otherwise, it returns an empty string and ends with fail. It also fails if
#   the project is installed under a different URL.
# PARAMETERS:
#   $1 - short repository URL
get_exact_install_record() {
    grep -m 1 -E -e '^'"$1"' .+$' "$GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes given directories if they are empty.
# PARAMETERS:
#   $@ - directories paths
rm_empty_dirs() {
    for dir in "$@"; do
        if [ -d "${dir:?}"/ ]; then
            rmdir --ignore-fail-on-non-empty -- "${dir:?}"/
        fi
    done
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Performs several checks, prepares target Git repository and executes the
#   given action itself. Requires gim's runtime to be already initialized.
# PARAMETERS:
#   $1 - action
#   $2 - repository URL
process_action() {
    # prepare Git URLs and check root permissions
    check_url "$2" &&
    repo_short_url="$(url_to_short_url "$2")" &&

    # prepare Git repository
    touch_repo "$repo_short_url" &&

    # clear error statuses
    error_statuses= &&

    # execute the action itself
    execute_action "$1" "$repo_short_url"
}

# DESCRIPTION:
#   Checks whether given URL is supported.
# PARAMETERS:
#   $1 - repository URL
check_url() {
    url_regex='^(|https://)[[:alnum:]_][[:alnum:]_\.-]*(/[[:alnum:]_][[:alnum:]_\.-]*){2}(|.git)$'
    # check the format of given repository URL
    if ! echo "$1" | grep -q -E -e "$url_regex"; then
        echo "$0: unsupported URL delivered" >&2
        return 1
    fi
}

# DESCRIPTION:
#   Transforms a given repository URL into its short variant.
# PARAMETERS:
#   $1 - repository URL
url_to_short_url() {
    echo "$1" | sed -E -e 's|^https://||; s/\.git$//'
}

#-------------------------------------------------------------------------------
# REPOSITORY OBTAINING
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Refreshes a Git repository from given URL. In case an associated directory
#   does not exist, it is created and the repository is cloned. Otherwise, the
#   repository is refreshed by fetching and merging changes.
# PARAMETERS:
#   $1 - short repository URL
touch_repo() { (
    mkdir -p "$GIM_CACHE_REPO_DIR"/"$1"/ &&
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ &&

    if [ ! "$(ls -A)" ]; then # if the cache directory for the target project is empty
        # clone the Git repository master branch to this directory, it can ask a user for a password
        git clone -q --branch master --single-branch "$(short_url_to_long_url "$1")" . &&
        # disable push remote URL
        git remote set-url --push origin ''
    else
        # remove all untracked files and directories (respect .gitignore for performance gains)
        git clean -q -d -f &&
        # discard all changes done to the repository
        git reset -q --hard &&

        # checkout the master branch
        git checkout -q master &&
        # fetch changes from master and merge them into local master branch
        git pull -q
    fi
) }

# DESCRIPTION:
#   Transforms a short repository URL into its long equivalent.
# PARAMETERS:
#   $1 - short repository URL
short_url_to_long_url() {
    echo https://"$1".git
}

#-------------------------------------------------------------------------------
# EXECUTE SELECTED ACTION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Executes a given action with an associated local Git repository prepared.
#   Also prints a report after executing the action.
# PARAMETERS:
#   $1 - action
#   $2 - short repository URL
execute_action() {
    # getting project information
    install_record="$(get_any_install_record "$2")"
    local_version="$(echo "$install_record" | sed -E -e 's/^[^ ]*(| )//')"
    repo_version="$(get_repo_version "$2")"

    # getting project status
    version_status="$(get_version_status "$local_version" "$repo_version")"
    report_status="$version_status"
    register_static_error_statuses "$2" "$local_version" "$repo_version"
    
    if [ ! "$error_statuses" ]; then
        case "$1" in
            "$ACTION_INSTALL")
                case "$version_status" in
                    "$VSTATUS_NO_SRC_VER")
                        report_status="$1"
                        install "$2" "$repo_version"
                        ;;
                    "$VSTATUS_DIFF")
                        report_status="$ACTION_UPDATE" # update, not an installation
                        update "$2" "$local_version" "$install_record" "$repo_version"
                        ;;
                esac
                ;;
            "$ACTION_UNINSTALL")
                case "$version_status" in
                    "$VSTATUS_MATCH" | "$VSTATUS_DIFF")
                        report_status="$1"
                        uninstall "$2" "$local_version" "$install_record"
                        ;;
                esac
                ;;
        esac
    fi

    if [ ! "$error_statuses" ] || [ "$1" = "$ACTION_STATUS" ]; then
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version"
    else
        print_status "$error_statuses" "$report_status" "$2" "$local_version" "$repo_version" >&2
        return 1
    fi
}

#-------------------------------------------------------------------------------
# PROJECT INFORMATION
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns first record, which represents an installation of the project from
#   the given URL. It also matches a different URLs. If nothing found, it
#   returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
get_any_install_record() {
    mirror_urls_path="$GIM_CACHE_REPO_DIR"/"$1"/gim/mirror-urls

    if [ -r "$mirror_urls_path" ]; then
        while read -r repo_mirror_url; do
            repo_mirror_url="$(url_to_short_url "$repo_mirror_url")"
            if install_record="$(get_exact_install_record "$repo_mirror_url")"; then
                echo "$install_record"
                break
            fi
        done < "$mirror_urls_path"
    elif install_record="$(get_exact_install_record "$1")"; then
        echo "$install_record"
    fi
}

# DESCRIPTION:
#   Returns the repository project version from the given URL. If no version or
#   repository found, empty string is returned and fails.
# PARAMETERS:
#   $1 - short repository URL
get_repo_version() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ &&
    git checkout -q master &&
    git describe --abbrev=0 2>/dev/null
) }

#-------------------------------------------------------------------------------
# PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Returns a status for two given versions.
# PARAMETERS:
#   $1 - source project version
#   $2 - target project version
get_version_status() {
    if [ ! "$1" ]; then
        echo "$VSTATUS_NO_SRC_VER"
    elif [ "$1" = "$2" ]; then
        echo "$VSTATUS_MATCH"
    else
        echo "$VSTATUS_DIFF"
    fi
}

# DESCRIPTION:
#   Returns static error statuses of the given Git project and versions
#   considering the '-force' flag if delivered without running any external
#   code. If there is at least one error status, a trailing space will be
#   appended. Otherwise, returns an empty string.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - target project version
register_static_error_statuses() {
    if [ ! "$3" ]; then
        add_error_status "$STATUS_NO_TAR_VER"
    fi
    
    if ! "$use_force" && ! is_supported_version "$1" "$2"; then
        add_error_status "$STATUS_UNSUP_SRC_VER"
    fi
}

# DESCRIPTION:
#   Adds a given error status to the global variable representing current gim's
#   error statuses.
# PARAMETERS:
#   $1 - error status
add_error_status() {
    error_statuses="$error_statuses""$1 "
}

# DESCRIPTION:
#   Decides whether a given version is supported within the project of given
#   repository URL.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - version
is_supported_version() {
    unsupported_versions_path="$GIM_CACHE_REPO_DIR"/"$1"/gim/unsupported-versions

    if [ -r "$unsupported_versions_path" ]; then
        while read -r unsupported_version; do
            if [ "$2" = "$unsupported_version" ]; then
                return 1
            fi
        done < "$unsupported_versions_path"
    fi
}

#-------------------------------------------------------------------------------
# CHOOSE AN INSTALLER
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Automatically chooses an installer and performs installation by delivered
#   arguments. If it succeeds, it will update gim's database.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
install() {
    # choose used installer for installation
    { installer="$(get_installer "$1" "$2")" || {
        add_error_status "$STATUS_NO_TAR_INSTALL"; false
    } } &&

    # perform an installation
    case "$installer" in
        "$INSTALLER_CAMI") cami_install "$1" "$2" ;;
        "$INSTALLER_MAKEI") makei_install "$1" "$2" ;;
    esac &&

    # access gim's database
    insert_install_record "$1 $2"
}

# DESCRIPTION:
#   Automatically chooses an installer and performs uninstallation by delivered
#   arguments. If it succeeds, it will update gim's database.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
uninstall() {
    # choose used installer for uninstallation
    { installer="$(get_installer "$1" "$2")" || {
        add_error_status "$STATUS_NO_SRC_UNINSTALL"; false
    } } &&

    # perform an uninstallation
    case "$installer" in
        "$INSTALLER_CAMI") cami_uninstall "$1" "$2" ;;
        "$INSTALLER_MAKEI") makei_uninstall "$1" "$2" ;;
    esac &&

    # access gim's database
    erase_install_record "$3"
}

# DESCRIPTION:
#   Automatically chooses an installer for uninstallation and an installer for
#   installation. Then performs a project update by delivered arguments. It
#   updates gim's database as per installation and uninstallation do.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
#   $3 - installation record to erase
#   $4 - target project version
update() {
    uninstall "$1" "$2" "$3" &&
    install "$1" "$4"
}

# DESCRIPTION:
#   Detects the most appropriate installer for given project and version. If
#   there is no such, it returns fail.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - project version
get_installer() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    if [ -x configure ]; then
        echo "$INSTALLER_CAMI"
    elif [ -e Makefile ] || [ -e makefile ]; then
        echo "$INSTALLER_MAKEI"
    else
        return 1 # no installer found, fail
    fi
) }

#-------------------------------------------------------------------------------
# CONFIGURE & MAKE INSTALLER
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Configure & Make installer uses standard Linux installation approach.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
cami_install() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # installation process
    { ./configure --prefix="$GIM_PREFIX"/ || {
        add_error_status "$STATUS_CONFIGURE_FAIL"; false
    } } &&
    { make || { add_error_status "$STATUS_MAKE_FAIL"; false; } } &&
    { make install || { add_error_status "$STATUS_MAKE_INSTALL_FAIL"; false; } }
) }

# DESCRIPTION:
#   Configure & Make installer uses standard Linux uninstallation approach.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
cami_uninstall() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # uninstallation process
    { ./configure --prefix="$GIM_PREFIX"/ || {
        add_error_status "$STATUS_CONFIGURE_FAIL"; false
    } } &&
    { make uninstall || { add_error_status "$STATUS_MAKE_UNINSTALL_FAIL"; false; } }
) }

#-------------------------------------------------------------------------------
# MAKE INSTALLER
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Make installer uses only a Makefile to install a project.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - target project version
makei_install() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # installation process
    { PREFIX="$GIM_PREFIX"/ make || {
        add_error_status "$STATUS_MAKE_FAIL"; false
    } } &&
    { PREFIX="$GIM_PREFIX"/ make install || {
        add_error_status "$STATUS_MAKE_INSTALL_FAIL"; false
    } }
) }

# DESCRIPTION:
#   Make installer uses only a Makefile to uninstall a project.
# PARAMETERS:
#   $1 - short repository URL
#   $2 - source project version
makei_uninstall() { (
    cd "$GIM_CACHE_REPO_DIR"/"$1"/ && # go to the repository
    git checkout -q -- "$2" && # use the given version as a tag

    # uninstallation process
    { PREFIX="$GIM_PREFIX"/ make uninstall || {
        add_error_status "$STATUS_MAKE_UNINSTALL_FAIL"; false
    } }
) }

#-------------------------------------------------------------------------------
# ACCESS GIM'S DATABASE
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Insert a given installation record before the first line of the gim status
#   list, performing no checks.
# PARAMETERS:
#   $1 - installation record
insert_install_record() {
    sed -i -E -e '1i '"$1" "$GIM_STATUS_PATH"
}

# DESCRIPTION:
#   Removes a given installation record from the gim status list, performing no
#   checks.
# PARAMETERS:
#   $1 - installation record
erase_install_record() {
    sed -i -E -e '\|'"$1"'|d' "$GIM_STATUS_PATH"
}

#-------------------------------------------------------------------------------
# PRINT PROJECT STATUS
#-------------------------------------------------------------------------------

# DESCRIPTION:
#   Prints the status of a given Git project and all associated parameters.
# PARAMETERS:
#   $1 - project statuses
#   $2 - report status
#   $3 - short repository URL
#   $4 - source project version
#   $5 - target project version
print_status() {
    common_prefix="$(create_labels "$1" '<' '>')""[$2] $3"
    case "$2" in
        "$ACTION_INSTALL") echo "$common_prefix $5" ;;
        "$ACTION_UPDATE") echo "$common_prefix $5 <- $4" ;;
        "$ACTION_UNINSTALL" | "$VSTATUS_MATCH") echo "$common_prefix $4" ;;
        "$VSTATUS_DIFF") echo "$common_prefix $4 -> $5" ;;
        "$VSTATUS_NO_SRC_VER") echo "$common_prefix${5:+" -> $5"}" ;;
    esac
}

# DESCRIPTION:
#   Create status labels from given string list and pattern. Uses IFS value to
#   separate label texts. If at least one label is created, a trailing space
#   will be appended.
# PARAMETERS:
#   $1 - string list
#   $2 - label leading string
#   $3 - label trailing string
create_labels() {
    labels=
    for label_text in $1; do
        labels="$labels""$2""$label_text""$3 "
    done
    echo "$labels"
}

#-------------------------------------------------------------------------------
# ENTRY POINT CALLING
#-------------------------------------------------------------------------------

main "$@" || exit
